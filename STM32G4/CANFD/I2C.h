/*
 * I2C.h
 *
 *  Created on: Feb 1, 2025
 *      Author: oleksii
 */

#ifndef INC_I2C_H_
#define INC_I2C_H_

#include <stdint.h>

#define TIMEOUT_I2C 160000 // Таймаут 1 мс при тактовой частоте 160 МГц


void I2C2_Init(void) {
    RCC->APB1ENR1 |= RCC_APB1ENR1_I2C2EN;
    //RCC->APB1RSTR1 |= RCC_APB1RSTR1_I2C2RST; // Устанавливаем бит сброса
    //RCC->APB1RSTR1 &= ~RCC_APB1RSTR1_I2C2RST; // Сбрасываем бит сброса
    I2C2->TIMINGR = 0x30D29DE4;// 400кгц 160 мгц  0x30420F13;/////////
    //I2C2->TIMINGR = ((9 << 28) | (10 << 20) | (9 << 16) | (799 << 8) | 799);  // 100 кГц

    I2C2->CR1 |= I2C_CR1_PE;   // Включаем I2C2
}

void I2C2_Write(uint8_t dev_addr, uint8_t reg_addr, uint8_t data) {
	   // Ожидание, пока шина не будет свободна
	    while (I2C2->ISR & I2C_ISR_BUSY);

	    // Установка адреса устройства и регистра для записи
	    I2C2->CR2 = (dev_addr << 1) | (2 << I2C_CR2_NBYTES_Pos) | I2C_CR2_START;
	    while (!(I2C2->ISR & I2C_ISR_TXIS)) {
	        if (I2C2->ISR & I2C_ISR_NACKF) {
	            // Обработка ошибки NACK (неподтверждение устройства)
	            I2C2->ICR |= I2C_ICR_NACKCF;  // Сброс флага NACK
	            return;  // Выход из функции при ошибке
	        }
	    }

	    // Отправка адреса регистра
	    I2C2->TXDR = reg_addr;
	    while (!(I2C2->ISR & I2C_ISR_TXIS)) {
	      if (I2C2->ISR & I2C_ISR_NACKF) {
	        // Обработка ошибки NACK (неподтверждение устройства)
	            I2C2->ICR |= I2C_ICR_NACKCF;  // Сброс флага NACK
	           return;  // Выход из функции при ошибке
	       }
	    }

	    // Отправка данных
	    I2C2->TXDR = data;
	    while (!(I2C2->ISR & I2C_ISR_TC)) {
	        if (I2C2->ISR & I2C_ISR_NACKF) {
	            // Обработка ошибки NACK (неподтверждение устройства)
	            I2C2->ICR |= I2C_ICR_NACKCF;  // Сброс флага NACK
	            return;  // Выход из функции при ошибке
	        }
	    }

	    // Завершение передачи
	    I2C2->CR2 |= I2C_CR2_STOP;
}

// info error



uint8_t I2C2_WriteCheck(uint8_t dev_addr, uint8_t reg_addr, uint8_t data) {

    // Ожидание, пока шина не будет свободна
    uint32_t timeout = TIMEOUT_I2C;
    while (I2C2->ISR & I2C_ISR_BUSY) {
        if (--timeout == 0) {
            return 1; // Ошибка: превышено время ожидания на BUSY
        }
    }
    // Установка адреса устройства и количества байтов для передачи
    I2C2->CR2 = (dev_addr << 1) | I2C_CR2_START | (2 << I2C_CR2_NBYTES_Pos);

    // Отправка адреса регистра
    I2C2->TXDR = reg_addr;

    // Ожидание отправки адреса регистра или таймаут
    timeout = TIMEOUT_I2C;
    while (!(I2C2->ISR & I2C_ISR_TXIS)) {
        if (--timeout == 0) {
            return 2; // Ошибка: превышено время ожидания на TXIS
        }
    }

    // Проверка на NACK
    if (I2C2->ISR & I2C_ISR_NACKF) {
        I2C2->ICR |= I2C_ICR_NACKCF; // Сброс флага NACK
        return 3; // Ошибка: NACK
    }

    // Отправка данных
    I2C2->TXDR = data;

    // Ожидание завершения передачи данных или таймаут
    timeout = TIMEOUT_I2C;
    while (!(I2C2->ISR & I2C_ISR_TC)) {
        if (--timeout == 0) {
            return 4; // Ошибка: превышено время ожидания на TC
        }
    }

    // Проверка на NACK
    if (I2C2->ISR & I2C_ISR_NACKF) {
        I2C2->ICR |= I2C_ICR_NACKCF; // Сброс флага NACK
        return 5; // Ошибка: NACK
    }

    // Завершение передачи
    I2C2->CR2 |= I2C_CR2_STOP;

    return 0; // Успех

}


///////////////////////////////////////////////////////////////////////


uint8_t I2C2_ReadByte(uint8_t dev_addr, uint8_t reg_addr) {
    uint8_t data = 0;

    // Ожидание, пока шина не будет свободна
    uint32_t timeout = TIMEOUT_I2C;
    while (I2C2->ISR & I2C_ISR_BUSY) {
        if (--timeout == 0) {
            return 0; // Ошибка: превышено время ожидания на BUSY
        }
    }

    // Установка адреса устройства и регистра для чтения
    I2C2->CR2 = (dev_addr << 1) | (1 << I2C_CR2_NBYTES_Pos) | I2C_CR2_START;

    timeout = TIMEOUT_I2C;
    while (!(I2C2->ISR & I2C_ISR_TXIS)) {
        if (--timeout == 0) {
            return 0; // Ошибка: превышено время ожидания на TXIS
        }
    }

    I2C2->TXDR = reg_addr;
    timeout = TIMEOUT_I2C;
    while (!(I2C2->ISR & I2C_ISR_TC)) {
        if (--timeout == 0) {
            return 0; // Ошибка: превышено время ожидания на TC
        }
        if (I2C2->ISR & I2C_ISR_NACKF) {
            // Обработка ошибки NACK (неподтверждение устройства)
            I2C2->ICR |= I2C_ICR_NACKCF;  // Сброс флага NACK
            return 0; // Возвращаем ошибку
        }
    }

    // Установка адреса устройства для чтения данных
    I2C2->CR2 = (dev_addr << 1) | I2C_CR2_RD_WRN | (1 << I2C_CR2_NBYTES_Pos) | I2C_CR2_START;
    timeout = TIMEOUT_I2C;
    while (!(I2C2->ISR & I2C_ISR_RXNE)) {
        if (--timeout == 0) {
            return 0; // Ошибка: превышено время ожидания на RXNE
        }
    }

    data = I2C2->RXDR;

    // Завершение передачи
    I2C2->CR2 |= I2C_CR2_STOP;

    return data; // Возвращаем считанное значение
}


uint8_t I2C2_ReadBytes(uint8_t dev_addr, uint8_t reg_addr, uint8_t *data, uint8_t length) {

    // Ожидание, пока шина не будет свободна
    uint32_t timeout = TIMEOUT_I2C;
    while (I2C2->ISR & I2C_ISR_BUSY) {
        if (--timeout == 0) {
            return 1; // Ошибка: превышено время ожидания на BUSY
        }
    }

    // Установка адреса устройства и регистра для чтения
    I2C2->CR2 = (dev_addr << 1) | (1 << I2C_CR2_NBYTES_Pos) | I2C_CR2_START;
    timeout = TIMEOUT_I2C;
    while (!(I2C2->ISR & I2C_ISR_TXIS)) {
        if (--timeout == 0) {
            return 2; // Ошибка: превышено время ожидания на TXIS
        }
    }

    I2C2->TXDR = reg_addr;
    timeout = TIMEOUT_I2C;
    while (!(I2C2->ISR & I2C_ISR_TC)) {
        if (--timeout == 0) {
            return 3; // Ошибка: превышено время ожидания на TC
        }
        if (I2C2->ISR & I2C_ISR_NACKF) {
            I2C2->ICR |= I2C_ICR_NACKCF;  // Сброс флага NACK
            return 4; // Ошибка: NACK
        }
    }

    // Установка адреса устройства для чтения данных
    I2C2->CR2 = (dev_addr << 1) | I2C_CR2_RD_WRN | (length << I2C_CR2_NBYTES_Pos) | I2C_CR2_START;
    timeout = TIMEOUT_I2C;
    while (!(I2C2->ISR & I2C_ISR_RXNE)) {
        if (--timeout == 0) {
            return 5; // Ошибка: превышено время ожидания на RXNE
        }
    }

    // Чтение данных
    for (uint8_t i = 0; i < length; i++) {
        timeout = TIMEOUT_I2C;
        while (!(I2C2->ISR & I2C_ISR_RXNE)) {
            if (--timeout == 0) {
                return 6; // Ошибка: превышено время ожидания на RXNE
            }
        }
        data[i] = I2C2->RXDR;
    }

    // Завершение передачи
    I2C2->CR2 |= I2C_CR2_STOP;

    return 0;
}




///////////////////////////////////////////////////////////////////////////


/*
 *
Регістр переривань і статусу I2C (I2C_ISR)

Адреса зсуву: 0x18

Значення після скидання: 0x0000 0001

Доступ: без очікування

31–24	23–17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
Res.	ADDCODE[6:0]	DIR	BUSY	Res.	ALERT	TIMEOUT	PECERR	OVR	ARLO	BERR	TCR	TC	STOPF	NACKF	ADDR	RXNE	TXIS
r	r	r	r	r	r	r	r	r	r	r	r	r	r	r	r	r	r	r
Опис бітів:
Біти 31:24 — Зарезервовано, повинні залишатися у значенні за замовчуванням.

Біти 23:17 — ADDCODE[6:0]: Код відповідності адреси (режим веденого)

Оновлюються отриманою адресою при виникненні події відповідності адреси (ADDR = 1). Для 10-бітної адреси ADDCODE містить 10-бітний заголовок, за яким слідують два старші біти адреси.

Біт 16 — DIR: Напрямок передачі (режим веденого)

Оновлюється при події відповідності адреси (ADDR = 1).

0: Передача на запис, ведений переходить у режим приймача.
1: Передача на читання, ведений переходить у режим передавача.
Біт 15 — BUSY: Зайнятість шини

Вказує на виконання передачі по шині. Встановлюється апаратно при виявленні умови START, скидається при виявленні STOP або при PE = 0.

Біт 14 — Зарезервовано, повинен залишатися у значенні за замовчуванням.

Біт 13 — ALERT: Сигнал тривоги SMBus

Встановлюється апаратно, якщо SMBHEN = 1, ALERTEN = 1 і виявлено спад на виводі SMBA (подія SMBALERT#). Скидається програмно встановленням біта ALERTCF.

Примітка: Скидається апаратно при PE = 0.

Біт 12 — TIMEOUT: Прапор таймауту або виявлення tLOW

Встановлюється апаратно при виникненні таймауту або розширеного таймауту тактування. Скидається програмно встановленням біта TIMEOUTCF.

Примітка: Скидається апаратно при PE = 0.

Біт 11 — PECERR: Помилка PEC при прийомі

Встановлюється апаратно, якщо прийнятий PEC не збігається з вмістом регістра PEC. Після неправильного PEC автоматично надсилається NACK. Скидається програмно встановленням біта PECCF.

Примітка: Скидається апаратно при PE = 0.

Біт 10 — OVR: Переповнення/недоповнення (режим веденого)

Встановлюється апаратно в режимі веденого з NOSTRETCH = 1 при виникненні помилки переповнення/недоповнення. Скидається програмно встановленням біта OVRCF.

Примітка: Скидається апаратно при PE = 0.

Біт 9 — ARLO: Втрата арбітражу

Встановлюється апаратно при втраті арбітражу. Скидається програмно встановленням біта ARLOCF.

Примітка: Скидається апаратно при PE = 0.

Біт 8 — BERR: Помилка шини

Встановлюється апаратно при виявленні некоректної умови START або STOP, якщо периферія бере участь у передачі. Не встановлюється під час фази адреси в режимі веденого. Скидається програмно встановленням біта BERRCF.

Примітка: Скидається апаратно при PE = 0.

Біт 7 — TCR: Завершення перезавантаження передачі

Встановлюється апаратно, якщо RELOAD = 1 і передано NBYTES даних. Скидається програмно при записі ненульового значення в NBYTES.

Примітка: Скидається апаратно при PE = 0. Використовується лише в режимі ведучого або в режимі веденого з установленим бітом SBC.

Біт 6 — TC: Завершення передачі (режим ведучого)

Встановлюється апаратно, якщо RELOAD = 0, AUTOEND = 0 і передано NBYTES даних. Скидається програмно при встановленні біта START або STOP.

Примітка: Скидається апаратно при PE = 0.

Біт 5 — STOPF: Прапор виявлення STOP

Встановлюється апаратно при виявленні умови STOP, якщо периферія бере участь у передачі:

У режимі ведучого, якщо STOP згенеровано периферією.
У режимі веденого, якщо периферія була адресована раніше у цій передачі.
Скидається програмно встановленням біта STOPCF.
Примітка: Скидається апаратно при PE = 0.
Біт 4 — NACKF: Прапор отримання NACK

Встановлюється апаратно при отриманні NACK після передачі байта. Скидається програмно встановленням біта NACKCF.

Примітка: Скидається апаратно при PE = 0.

Біт 3 — ADDR: Відповідність адреси (режим веденого)

Встановлюється апаратно, щойно прийнята адреса веденого збігається з однією з дозволених адрес. Скидається програмно встановленням біта ADDRCF.

Примітка: Скидається апаратно при PE = 0.

Біт 2 — RXNE: Регістр даних прийому не порожній (приймачі)

Встановлюється апаратно, коли отримані дані скопійовано в регістр I2C_RXDR і готові до читання. Скидається при читанні I2C_RXDR.

Примітка: Скидається апаратно при PE = 0.

Біт 1 — TXIS: Статус переривання передачі (передавачі)

Встановлюється апаратно, коли регістр I2C_TXDR порожній, і дані для передачі мають бути записані в I2C_TXDR. Скидається при записі наступних даних у I2C_TXDR.

Цей біт можна встановити в 1 програмно лише при NOSTRETCH = 1 для генерації події TXIS (переривання, якщо TXIE = 1, або запит DMA, якщо TXDMA увімкнено).

Біт 0 — Зарезервовано (у цьому описі не вказано, але в деяких реалізаціях може бути TXE, хоча тут не описано).
 *
 *
 *
 *
 Регістр очищення переривань I2C (I2C_ICR)
Адреса зсуву: 0x1C

Значення після скидання: 0x0000 0000

Доступ: без очікування

| 31–14 | 13 | 12 | 11 | 10 | 9 | 8 | 7–6 | 5 | 4 | 3 | 2–0 |
|-------|----|----|----|----|---|-------|-------|-------|-------|-------|
| Res. | ALERTCF | TIMOUTCF | PECCF | OVRCF | ARLOCF | BERRCF | Res. | STOPCF | NACKCF | ADDRCF | Res. |
| - | w | w | w | w | w | w | - | w | w | w | - |

Опис бітів:
Біти 31:14 — Зарезервовано, повинні залишатися у значенні за замовчуванням.

Біт 13 — ALERTCF: Очищення прапора тривоги

Запис 1 у цей біт очищає прапор ALERT у регістрі I2C_ISR.

Біт 12 — TIMOUTCF: Очищення прапора таймауту

Запис 1 у цей біт очищає прапор TIMEOUT у регістрі I2C_ISR.

Біт 11 — PECCF: Очищення прапора помилки PEC

Запис 1 у цей біт очищає прапор PECERR у регістрі I2C_ISR.

Біт 10 — OVRCF: Очищення прапора переповнення/недоповнення

Запис 1 у цей біт очищає прапор OVR у регістрі I2C_ISR.

Біт 9 — ARLOCF: Очищення прапора втрати арбітражу

Запис 1 у цей біт очищає прапор ARLO у регістрі I2C_ISR.

Біт 8 — BERRCF: Очищення прапора помилки шини

Запис 1 у цей біт очищає прапор BERR у регістрі I2C_ISR.

Біти 7:6 — Зарезервовано, повинні залишатися у значенні за замовчуванням.

Біт 5 — STOPCF: Очищення прапора виявлення STOP

Запис 1 у цей біт очищає прапор STOPF у регістрі I2C_ISR.

Біт 4 — NACKCF: Очищення прапора неотримання підтвердження

Запис 1 у цей біт очищає прапор NACKF у регістрі I2C_ISR.

Біт 3 — ADDRCF: Очищення прапора відповідності адреси

Запис 1 у цей біт очищає прапор ADDR у регістрі I2C_ISR. Також запис 1 у цей біт очищає біт START у регістрі I2C_CR2.

Біти 2:0 — Зарезервовано, повинні залишатися у значенні за замовчуванням.

Якщо потрібні додаткові пояснення чи приклади, повідомте!
 *
 *
 *
 *
 *
 *
 *
void DMA_Init(void) {
    // Включение тактирования DMA1
    RCC->AHB1ENR |= RCC_AHB1ENR_DMA1EN;

    // Настройка DMA для I2C2
    DMA1_Channel1->CCR &= ~DMA_CCR_EN; // Отключение канала
    DMA1_Channel1->CPAR = (uint32_t)&I2C2->TXDR; // Адрес периферии
    DMA1_Channel1->CMAR = (uint32_t)dataToSend; // Адрес памяти (измените на нужный)
    DMA1_Channel1->CNDTR = 10; // Количество данных для передачи
    DMA1_Channel1->CCR |= DMA_CCR_DIR | DMA_CCR_MINC | DMA_CCR_TCIE; // Настройка канала
    NVIC_EnableIRQ(DMA1_Channel1_IRQn); // Разрешение прерывания
}

void I2C2_DMA_Transmit(uint8_t* data, uint16_t size) {
    // Настройка DMA для передачи
    DMA1_Channel1->CMAR = (uint32_t)data; // Установка адреса памяти
    DMA1_Channel1->CNDTR = size; // Установка количества данных

    // Запуск передачи
    I2C2->CR2 |= (size << 16); // Установка количества байтов
    I2C2->CR2 |= (I2C2_ADDRESS << 1); // Установка адреса устройства
    I2C2->CR2 |= I2C_CR2_START; // Начало передачи

    // Включение DMA
    DMA1_Channel1->CCR |= DMA_CCR_EN;
}

void DMA1_Channel1_IRQHandler(void) {
    if (DMA1->ISR & DMA_ISR_TCIF1) { // Проверка флага завершения передачи
        DMA1->IFCR |= DMA_IFCR_CTCIF1; // Сброс флага
        I2C2->CR2 |= I2C_CR2_STOP; // Завершение передачи
    }
}
 * */






















#endif /* INC_I2C_H_ */
