Элемент Rx FIFO в FDCAN
В модуле FDCAN (Flexible Data-Rate Controller Area Network) микроконтроллера STM32G431 два FIFO буфера приема (Rx FIFO) конфигурируются в памяти сообщений (Message RAM). Каждый из этих Rx FIFO может быть настроен для хранения до трех принятых сообщений. Структура элемента Rx FIFO описана ниже.

Структура элемента Rx FIFO
Структура элемента Rx FIFO включает несколько полей, каждое из которых имеет свое назначение. Таблица 405 и Таблица 406 описывают структуру и назначение каждого поля элемента Rx FIFO.

Таблица 405. Элемент Rx FIFO
31	ESI	Индикатор состояния ошибки
30	XTD	Расширенный идентификатор
29	RTR	Запрос удаленной передачи
28:0	ID	Идентификатор сообщения
31	ANMF	Принятое несовпадающее сообщение
30:24	FIDX	Индекс фильтра
21	FDF	Формат кадра FDCAN
20	BRS	Переключатель скорости передачи
19:16	DLC	Код длины данных
15:0	RXTS	Метка времени приема
31:24	DB7	Байты данных
23:16	DB6	Байты данных
15:8	DB5	Байты данных
7:0	DB4	Байты данных
31:24	DBm	Байты данных
23:16	DBm-1	Байты данных
15:8	DBm-2	Байты данных
7:0	DBm-3	Байты данных


Таблица 406. Описание элемента Rx FIFO
ESI	31	Индикатор состояния ошибки (0: узел передающий активен, 1: узел передающий пассивен)
XTD	30	Расширенный идентификатор (0: стандартный 11-битный идентификатор, 1: расширенный 29-битный идентификатор)
RTR	29	Запрос удаленной передачи (0: кадр данных, 1: удаленный кадр)
ID	28:0	Идентификатор сообщения (в зависимости от XTD, стандартный или расширенный)
ANMF	31	Принятое несовпадающее сообщение (0: сообщение соответствует фильтру, 1: сообщение не соответствует ни одному фильтру)
FIDX	30:24	Индекс фильтра (0-27, недействителен, если ANMF = 1)
FDF	21	Формат кадра FDCAN (0: стандартный формат, 1: формат FDCAN)
BRS	20	Переключатель скорости передачи (0: без переключения, 1: с переключением скорости)
DLC	19:16	Код длины данных (0-8: классический CAN + CAN FD: кадр с 0-8 байтами данных, 9-15: CAN FD: кадр с 12/16/20/24/32/48/64 байтами данных)
RXTS	15:0	Метка времени приема (значение счетчика меток времени, захваченное в момент начала приема кадра)
DB3	31:24	Байты данных
DB2	23:16	Байты данных
DB1	15:8	Байты данных
D	7:0	Байты данных
DB7	31:24	Байты данных
DB6	23:16	Байты данных
DB5	15:8	Байты данных
DB4	7:0	Байты данных
DBm	31:24	Байты данных
DBm-1	23:16	Байты данных
DBm-2	15:8	Байты данных
DBm-3	7:0	Байты данных

#include "stm32g4xx.h"

// Функция для инициализации FDCAN
void FDCAN_Config(void) {
    // Включение тактирования для FDCAN и GPIO
    RCC->APB1ENR1 |= RCC_APB1ENR1_FDCANEN;
    RCC->AHB2ENR |= RCC_AHB2ENR_GPIOAEN | RCC_AHB2ENR_GPIOBEN;

    // Настройка PA11 (CAN_RX) и PB9 (CAN_TX) в режим альтернативной функции
    GPIOA->MODER &= ~(GPIO_MODER_MODE11);
    GPIOA->MODER |= GPIO_MODER_MODE11_1;
    GPIOA->AFR[1] |= (9 << GPIO_AFRH_AFSEL11_Pos);

    GPIOB->MODER &= ~(GPIO_MODER_MODE9);
    GPIOB->MODER |= GPIO_MODER_MODE9_1;
    GPIOB->AFR[1] |= (9 << GPIO_AFRH_AFSEL9_Pos);

    // Настройка FDCAN
    FDCAN_GlobalTypeDef *CAN = FDCAN1;

    // Выключаем FDCAN перед настройкой
    CAN->CCCR |= FDCAN_CCCR_INIT;
    while (!(CAN->CCCR & FDCAN_CCCR_INIT));

    // Настройка битрейта для скорости 500 кбит/с
    CAN->CCCR |= FDCAN_CCCR_CCE;
    CAN->NBTP = (14 << FDCAN_NBTP_NBRP_Pos) | (15 << FDCAN_NBTP_NTSEG1_Pos) | (4 << FDCAN_NBTP_NTSEG2_Pos);

    // Настройка завершена
    CAN->CCCR &= ~FDCAN_CCCR_INIT;
}

// Функция для чтения одного элемента из Rx FIFO 0
void FDCAN_ReadRxFIFO0(void) {
    // Проверка наличия данных в Rx FIFO 0
    if (FDCAN1->RXF0S & FDCAN_RXF0S_F0FL) {
        // Получение текущего индекса чтения
        uint32_t getIndex = (FDCAN1->RXF0S & FDCAN_RXF0S_F0GI) >> FDCAN_RXF0S_F0GI_Pos;

        // Адрес буфера Rx FIFO 0
        uint32_t *rxBuffer = (uint32_t *)(FDCAN1->RXF0A + getIndex * 18 * 4); // 18 слов по 4 байта

        // Чтение заголовка сообщения
        uint32_t rxHeader0 = rxBuffer[0];
        uint32_t rxHeader1 = rxBuffer[1];

        // Извлечение полей из заголовка
        uint8_t ESI = (rxHeader0 >> 31) & 0x1;
        uint8_t XTD = (rxHeader0 >> 30) & 0x1;
        uint8_t RTR = (rxHeader0 >> 29) & 0x1;
        uint32_t ID = rxHeader0 & 0x1FFFFFFF;

        uint8_t ANMF = (rxHeader1 >> 31) & 0x1;
        uint8_t FIDX = (rxHeader1 >> 24) & 0x7F;
        uint8_t FDF = (rxHeader1 >> 21) & 0x1;
        uint8_t BRS = (rxHeader1 >> 20) & 0x1;
        uint8_t DLC = (rxHeader1 >> 16) & 0xF;
        uint16_t RXTS = rxHeader1 & 0xFFFF;

        // Чтение данных сообщения
        uint8_t rxData[64];
        for (int i = 0; i < DLC; i++) {
            rxData[i] = *((uint8_t *)(rxBuffer + 2 + i));
        }

        // Обработка принятого сообщения
        // Ваш код обработки здесь

        // Обновление индекса подтверждения
        FDCAN1->RXF0A = getIndex;
    }
}

int main(void) {
    // Настройка системного тактирования (предполагается, что уже настроено)
    // SystemClock_Config();

    // Настройка FDCAN
    FDCAN_Config();

    while (1) {
        // Чтение элементов из Rx FIFO 0
        FDCAN_ReadRxFIFO0();
    }
}

void Error_Handler(void) {
    // Обработка ошибок
    __disable_irq();
    while (1) {
    }
}



Элемент буфера передачи (Tx Buffer Element) в FDCAN
Элементы буфера передачи (Tx Buffers) в модуле FDCAN (Flexible Data-Rate Controller Area Network) микроконтроллера STM32G431 могут быть настроены для хранения Tx FIFO или Tx очереди (Tx Queue). Размер элемента буфера настроен для хранения сообщений CAN FD с данными до 64 байт. Работа с буферами передачи различается в зависимости от значения бита конфигурации TFQM регистра FDCAN_TXBC.

Структура элемента буфера передачи
Элемент буфера передачи состоит из нескольких полей, каждое из которых имеет свое назначение. Таблица 407 и Таблица 408 описывают структуру и назначение каждого поля элемента буфера передачи.

Таблица 407. Элемент буфера передачи и FIFO
31	ESI	Индикатор состояния ошибки
30	XTD	Расширенный идентификатор
29	RTR	Запрос удаленной передачи
28:0	ID	Идентификатор сообщения
31:24	MM	Маркер сообщения
23	EFC	Управление FIFO событий
21	FDF	Формат кадра FDCAN
20	BRS	Переключатель скорости передачи
19:16	DLC	Код длины данных
31:24	DB3	Байты данных
23:16	DB2	Байты данных
15:8	DB1	Байты данных
7:0	D	Байты данных
31:24	DB7	Байты данных
23:16	DB6	Байты данных
15:8	DB5	Байты данных
7:0	DB4	Байты данных
31:24	DBm	Байты данных
23:16	DBm-1	Байты данных
15:8	DBm-2	Байты данных
7:0	DBm-3	Байты данных

Таблица 408. Описание элемента буфера передачи
ESI	31	Индикатор состояния ошибки (0: бит ESI в формате CAN FD зависит только от флага пассивной ошибки, 1: бит ESI в формате CAN FD передается рецессивно)
XTD	30	Расширенный идентификатор (0: 11-битный стандартный идентификатор, 1: 29-битный расширенный идентификатор)
RTR	29	Запрос удаленной передачи (0: передача кадра данных, 1: передача удаленного кадра)
ID	28:0	Идентификатор сообщения (в зависимости от XTD, стандартный или расширенный)
MM	31:24	Маркер сообщения, записываемый ЦП во время конфигурации буфера передачи. Копируется в элемент Tx FIFO событий для идентификации статуса сообщения.
EFC	23	Управление FIFO событий (0: не сохранять события передачи, 1: сохранять события передачи)
FDF	21	Формат кадра FDCAN (0: передача в классическом формате CAN, 1: передача в формате CAN FD)
BRS	20	Переключатель скорости передачи (0: передача кадров CAN FD без переключения скорости, 1: передача кадров CAN FD с переключением скорости)
DLC	19:16	Код длины данных (0-8: классический CAN + CAN FD: кадр имеет 0-8 байт данных, 9-15: классический CAN: кадр имеет 8 байт данных, 9-15: CAN FD: кадр имеет 12/16/20/24/32/48/64 байт данных)
DB3	31:24	Байты данных
DB2	23:16	Байты данных
DB1	15:8	Байты данных
D	7:0	Байты данных
DB7	31:24	Байты данных
DB6	23:16	Байты данных
DB5	15:8	Байты данных
DB4	7:0	Байты данных
DBm	31:24	Байты данных
DBm-1	23:16	Байты данных
DBm-2	15:8	Байты данных
DBm-3	7:0	Байты данных
Пример кода для записи элемента в буфер передачи
Вот пример кода на языке C для записи элемента в буфер передачи в FDCAN:

C
#include "stm32g4xx.h"

// Функция для инициализации FDCAN
void FDCAN_Config(void) {
    // Включение тактирования для FDCAN и GPIO
    RCC->APB1ENR1 |= RCC_APB1ENR1_FDCANEN;
    RCC->AHB2ENR |= RCC_AHB2ENR_GPIOAEN | RCC_AHB2ENR_GPIOBEN;

    // Настройка PA11 (CAN_RX) и PB9 (CAN_TX) в режим альтернативной функции
    GPIOA->MODER &= ~(GPIO_MODER_MODE11);
    GPIOA->MODER |= GPIO_MODER_MODE11_1;
    GPIOA->AFR[1] |= (9 << GPIO_AFRH_AFSEL11_Pos);

    GPIOB->MODER &= ~(GPIO_MODER_MODE9);
    GPIOB->MODER |= GPIO_MODER_MODE9_1;
    GPIOB->AFR[1] |= (9 << GPIO_AFRH_AFSEL9_Pos);

    // Настройка FDCAN
    FDCAN_GlobalTypeDef *CAN = FDCAN1;

    // Выключаем FDCAN перед настройкой
    CAN->CCCR |= FDCAN_CCCR_INIT;
    while (!(CAN->CCCR & FDCAN_CCCR_INIT));

    // Настройка битрейта для скорости 500 кбит/с
    CAN->CCCR |= FDCAN_CCCR_CCE;
    CAN->NBTP = (14 << FDCAN_NBTP_NBRP_Pos) | (15 << FDCAN_NBTP_NTSEG1_Pos) | (4 << FDCAN_NBTP_NTSEG2_Pos);

    // Настройка завершена
    CAN->CCCR &= ~FDCAN_CCCR_INIT;
}

// Функция для записи элемента в буфер передачи
void FDCAN_WriteTxBuffer(void) {
    // Проверка наличия свободного буфера передачи
    if (FDCAN1->TXFQS & FDCAN_TXFQS_TFQF) {
        // Очередь передачи заполнена
        return;
    }

    // Получение индекса вставки
    uint32_t putIndex = (FDCAN1->TXFQS & FDCAN_TXFQS_TFQPI) >> FDCAN_TXFQS_TFQPI_Pos;

    // Адрес буфера передачи
    uint32_t *txBuffer = (uint32_t *)(FDCAN1->TXBSA + putIndex * 18 * 4); // 18 слов по 4 байта

    // Заполнение заголовка сообщения
    txBuffer[0] = (0 << 31) | (0 << 30) | (0 << 29) | (0x123 << 0); // ESI, XTD, RTR, ID
    txBuffer[1] = (0xA5 << 24) | (1 << 23) | (1 << 21) | (1 << 20) | (8 << 16); // MM, EFC, FDF, BRS, DLC

    // Заполнение данных сообщения
    txBuffer[2] = (0x11 << 24) | (0x22 << 16) | (0x33 << 8) | 0x44; // DB3, DB2, DB1, D
    txBuffer[3] = (0x55 << 24) | (0x66 << 16) | (0x77 << 8) | 0x88; // DB7, DB6, DB5, DB4

    // Запрос на передачу сообщения
    FDCAN1->TXBAR = (1 << putIndex);
}

int main(void) {
    // Настройка системного тактирования (предполагается, что уже настроено)
    // SystemClock_Config();

    // Настройка FDCAN
    FDCAN_Config();

    while (1) {
        // Запись элемента в буфер передачи и отправка сообщения
        FDCAN_WriteTxBuffer();
        for (volatile uint32_t i = 0; i < 1000000; i++); // Задержка
    }
}

void Error_Handler(void) {
    // Обработка ошибок
    __disable_irq();
    while (1) {
    }
}

Фильтры идентификаторов сообщений FDCAN
Модуль FDCAN в микроконтроллере STM32G431 поддерживает фильтрацию входящих сообщений на основе идентификаторов сообщений. Существует два типа фильтров: для стандартных 11-битных идентификаторов и для расширенных 29-битных идентификаторов. Эти фильтры позволяют конфигурировать правила приема сообщений, такие как прием в определенные FIFO или приоритетную обработку.

Фильтры стандартных 11-битных идентификаторов сообщений
До 28 фильтров могут быть настроены для 11-битных стандартных идентификаторов. Адрес фильтра определяется как начальный адрес списка фильтров (FLSSA) плюс индекс элемента фильтра (0…27).

Таблица 411. Элемент фильтра стандартного сообщения
31:30	SFT	Тип стандартного фильтра
29:27	SFEC	Конфигурация элемента стандартного фильтра
26:16	SFID1	Первый идентификатор фильтра
10:0	SFID2	Второй идентификатор фильтра
Таблица 412. Описание полей элемента фильтра стандартного сообщения
SFT	Тип стандартного фильтра (Standard Filter Type):
- 00: Диапазон фильтров от SFID1 до SFID2
- 01: Двойной ID фильтр для SFID1 или SFID2
- 02: Классический фильтр: SFID1 = фильтр, SFID2 = маска
- 11: Фильтр отключен
SFEC	Конфигурация элемента стандартного фильтра (Standard Filter Element Configuration):
- 000: Отключить элемент фильтра
- 001: Сохранить в Rx FIFO 0, если фильтр совпадает
- 010: Сохранить в Rx FIFO 1, если фильтр совпадает
- 011: Отклонить ID, если фильтр совпадает
- 100: Установить приоритет, если фильтр совпадает
- 101: Установить приоритет и сохранить в FIFO 0, если фильтр совпадает
- 110: Установить приоритет и сохранить в FIFO 1, если фильтр совпадает
- 111: Не используется
SFID1	Первый идентификатор фильтра (Standard Filter ID 1): Первый ID элемента фильтра
SFID2	Второй идентификатор фильтра (Standard Filter ID 2): Второй ID элемента фильтра
Фильтры расширенных 29-битных идентификаторов сообщений
До восьми фильтров могут быть настроены для 29-битных расширенных идентификаторов. Адрес фильтра определяется как начальный адрес списка фильтров (FLESA) плюс удвоенный индекс элемента фильтра (0…7).

Таблица 413. Элемент фильтра расширенного сообщения
31:29	EFEC	Конфигурация элемента расширенного фильтра
28:0	EFID1	Первый идентификатор фильтра
31:30	EFT	Тип расширенного фильтра
29		Не используется
28:0	EFID2	Второй идентификатор фильтра
Таблица 414. Описание полей элемента фильтра расширенного сообщения
EFEC	Конфигурация элемента расширенного фильтра (Extended Filter Element Configuration):
- 000: Отключить элемент фильтра
- 001: Сохранить в Rx FIFO 0, если фильтр совпадает
- 002: Сохранить в Rx FIFO 1, если фильтр совпадает
- 003: Отклонить ID, если фильтр совпадает
- 100: Установить приоритет, если фильтр совпадает
- 101: Установить приоритет и сохранить в FIFO 0, если фильтр совпадает
- 110: Установить приоритет и сохранить в FIFO 1, если фильтр совпадает
- 111: Не используется
EFID1	Первый идентификатор фильтра (Extended Filter ID 1): Первый ID элемента фильтра
EFT	Тип расширенного фильтра (Extended Filter Type):
- 00: Диапазон фильтров от EFID1 до EFID2 (EFID2 ≥ EFID1)
- 01: Двойной ID фильтр для EFID1 или EFID2
- 10: Классический фильтр: EFID1 = фильтр, EFID2 = маска
- 11: Диапазон фильтров от EFID1 до EFID2 (EFID2 ≥ EFID1), маска XIDAM не применяется
EFID2	Второй идентификатор фильтра (Extended Filter ID 2): Второй ID элемента фильтра
Пример настройки фильтров
Ниже приведен пример кода на языке C для настройки фильтров стандартных и расширенных идентификаторов сообщений в FDCAN.

Пример кода
C
#include "stm32g4xx.h"

// Функция для инициализации FDCAN
void FDCAN_Config(void) {
    // Включение тактирования для FDCAN и GPIO
    RCC->APB1ENR1 |= RCC_APB1ENR1_FDCANEN;
    RCC->AHB2ENR |= RCC_AHB2ENR_GPIOAEN | RCC_AHB2ENR_GPIOBEN;

    // Настройка PA11 (CAN_RX) и PB9 (CAN_TX) в режим альтернативной функции
    GPIOA->MODER &= ~(GPIO_MODER_MODE11);
    GPIOA->MODER |= GPIO_MODER_MODE11_1;
    GPIOA->AFR[1] |= (9 << GPIO_AFRH_AFSEL11_Pos);

    GPIOB->MODER &= ~(GPIO_MODER_MODE9);
    GPIOB->MODER |= GPIO_MODER_MODE9_1;
    GPIOB->AFR[1] |= (9 << GPIO_AFRH_AFSEL9_Pos);

    // Настройка FDCAN
    FDCAN_GlobalTypeDef *CAN = FDCAN1;

    // Выключаем FDCAN перед настройкой
    CAN->CCCR |= FDCAN_CCCR_INIT;
    while (!(CAN->CCCR & FDCAN_CCCR_INIT));

    // Настройка битрейта для скорости 500 кбит/с
    CAN->CCCR |= FDCAN_CCCR_CCE;
    CAN->NBTP = (14 << FDCAN_NBTP_NBRP_Pos) | (15 << FDCAN_NBTP_NTSEG1_Pos) | (4 << FDCAN_NBTP_NTSEG2_Pos);

    // Настройка фильтров стандартных сообщений
    uint32_t *stdFilter = (uint32_t *)(CAN->FLSSA);
    stdFilter[0] = (1 << 30) | (1 << 27) | (0x123 << 16) | (0x12F); // SFT = 01, SFEC = 001, SFID1 = 0x123, SFID2 = 0x12F

    // Настройка фильтров расширенных сообщений
    uint32_t *extFilter = (uint32_t *)(CAN->FLESA);
    extFilter[0] = (1 << 29) | (1 << 27) | (0x1234567); // EFEC = 001, EFID1 = 0x1234567
    extFilter[1] = (1 << 29) | (0x123456F); // EFT = 01, EFID2 = 0x123456F

    // Завершение настройки
    CAN->CCCR &= ~FDCAN_CCCR_INIT;
}

int main(void) {
    // Настройка системного тактирования (предполагается, что уже настроено)
    // SystemClock_Config();

    // Настройка FDCAN
    FDCAN_Config();

    while (1) {
        // Основной цикл
    }
}

void Error_Handler(void) {
    // Обработка ошибок
    __disable_irq();
    while (1) {
    }
}
Объяснение кода:
FDCAN_Config():

Включается тактирование для FDCAN и GPIO.
Настраиваются пины PA11 и PB9 в режим альтернативной функции (AF9 для CAN).
Выполняется настройка битрейта FDCAN.
Настраиваются фильтры стандартных и расширенных сообщений.
Завершается настройка и включается FDCAN.
main():

Настраивается FDCAN.
Основной цикл программы.
Этот пример демонстрирует, как настроить фильтры стандартных и расширенных идентификаторов сообщений в модуле FDCAN на микроконтроллере STM32G431.


Да, маска для фильтров идентификаторов сообщений в FDCAN хранится в поле фильтров. Для стандартных 11-битных идентификаторов и расширенных 29-битных идентификаторов сообщения используются разные поля для хранения маски.

Режим маски для стандартных 11-битных идентификаторов (Classic Filter)
Для стандартных 11-битных идентификаторов в режиме маски (SFT = 10), поле SFID2 используется для хранения маски. Маска задает, какие биты идентификатора сообщения должны быть проверены при фильтрации.

Пример настройки стандартного фильтра в режиме маски
C
uint32_t *stdFilter = (uint32_t *)(CAN->FLSSA);
// Настройка фильтра: SFT = 10 (режим маски), SFEC = 001 (сохранить в Rx FIFO 0), SFID1 = 0x123 (идентификатор), SFID2 = 0x7FF (маска)
stdFilter[0] = (2 << 30) | (1 << 27) | (0x123 << 16) | (0x7FF);
Режим маски для расширенных 29-битных идентификаторов (Classic Filter)
Для расширенных 29-битных идентификаторов в режиме маски (EFT = 10), поле EFID2 используется для хранения маски. Маска задает, какие биты идентификатора сообщения должны быть проверены при фильтрации.

Пример настройки расширенного фильтра в режиме маски
C
uint32_t *extFilter = (uint32_t *)(CAN->FLESA);
// Настройка фильтра: EFEC = 001 (сохранить в Rx FIFO 0), EFID1 = 0x1234567 (идентификатор), EFT = 10 (режим маски), EFID2 = 0x1FFFFFFF (маска)
extFilter[0] = (1 << 29) | (1 << 27) | (0x1234567);
extFilter[1] = (2 << 30) | (0x1FFFFFFF);
Объяснение полей фильтров
Поля стандартного фильтра (Таблица 411)
SFT (Standard Filter Type): Тип стандартного фильтра

00: Диапазон фильтров от SFID1 до SFID2
01: Двойной ID фильтр для SFID1 или SFID2
10: Классический фильтр: SFID1 = фильтр, SFID2 = маска
11: Фильтр отключен
SFEC (Standard Filter Element Configuration): Конфигурация элемента стандартного фильтра

000: Отключить элемент фильтра
001: Сохранить в Rx FIFO 0, если фильтр совпадает
010: Сохранить в Rx FIFO 1, если фильтр совпадает
011: Отклонить ID, если фильтр совпадает
100: Установить приоритет, если фильтр совпадает
101: Установить приоритет и сохранить в FIFO 0, если фильтр совпадает
110: Установить приоритет и сохранить в FIFO 1, если фильтр совпадает
111: Не используется
SFID1: Первый идентификатор фильтра (Standard Filter ID 1)

SFID2: Второй идентификатор фильтра (Standard Filter ID 2)

Поля расширенного фильтра (Таблица 413)
EFEC (Extended Filter Element Configuration): Конфигурация элемента расширенного фильтра

000: Отключить элемент фильтра
001: Сохранить в Rx FIFO 0, если фильтр совпадает
010: Сохранить в Rx FIFO 1, если фильтр совпадает
011: Отклонить ID, если фильтр совпадает
100: Установить приоритет, если фильтр совпадает
101: Установить приоритет и сохранить в FIFO 0, если фильтр совпадает
110: Установить приоритет и сохранить в FIFO 1, если фильтр совпадает
111: Не используется
EFID1: Первый идентификатор фильтра (Extended Filter ID 1)

EFT (Extended Filter Type): Тип расширенного фильтра

00: Диапазон фильтров от EFID1 до EFID2 (EFID2 ≥ EFID1)
01: Двойной ID фильтр для EFID1 или EFID2
10: Классический фильтр: EFID1 = фильтр, EFID2 = маска
11: Диапазон фильтров от EFID1 до EFID2 (EFID2 ≥ EFID1), маска XIDAM не применяется
EFID2: Второй идентификатор фильтра (Extended Filter ID 2)

Заключение
Режим маски позволяет гибко фильтровать сообщения в FDCAN, используя соответствующие поля для стандартных и расширенных идентификаторов. Это позволяет принимать или отклонять сообщения на основе заданных условий, определенных маской.



### Регистр управления FDCAN CC (FDCAN_CCCR)

Регистр управления FDCAN CC (FDCAN_CCCR) используется для настройки различных параметров и режимов работы модуля FDCAN. Этот регистр имеет смещение адреса 0x0018 и значение по умолчанию 0x0000 0001 после сброса.

#### Описание полей регистра FDCAN_CCCR

| Бит    | Поле  | Описание                          |
|--------|-------|-----------------------------------|
| 31:16  |       | Зарезервировано, должно быть установлено в значение по умолчанию. |
| 15     | NISO  | Non-ISO operation: Использование формата кадров CAN FD, как указано в спецификации Bosch CAN FD V1.0. |
|        |       | - 0: Формат кадров CAN FD согласно ISO11898-1. |
|        |       | - 1: Формат кадров CAN FD согласно спецификации Bosch CAN FD V1.0. |
| 14     | TXP   | Transmit pause enable: Включение паузы перед следующей передачей после успешной передачи кадра. |
|        |       | - 0: Отключено. |
|        |       | - 1: Включено (пауза на два CAN бита перед следующей передачей). |
| 13     | EFBI  | Edge filtering during bus integration: Фильтрация фронтов при интеграции на шине. |
|        |       | - 0: Фильтрация фронтов отключена. |
|        |       | - 1: Для обнаружения фронта требуется два последовательных доминантных tq. |
| 12     | PXHD  | Protocol exception handling disable: Отключение обработки исключений протокола. |
|        |       | - 0: Обработка исключений протокола включена. |
|        |       | - 1: Обработка исключений протокола отключена. |
| 11:10  |       | Зарезервировано, должно быть установлено в значение по умолчанию. |
| 9      | BRSE  | FDCAN bit rate switching: Переключение скорости передачи для FDCAN. |
|        |       | - 0: Переключение скорости передачи отключено. |
|        |       | - 1: Переключение скорости передачи включено. |
| 8      | FDOE  | FD operation enable: Включение работы в режиме FD. |
|        |       | - 0: Работа в режиме FD отключена. |
|        |       | - 1: Работа в режиме FD включена. |
| 7      | TEST  | Test mode enable: Включение тестового режима. |
|        |       | - 0: Нормальная работа, регистр FDCAN_TEST удерживает значения по умолчанию. |
|        |       | - 1: Тестовый режим, разрешен доступ на запись в регистр FDCAN_TEST. |
| 6      | DAR   | Disable automatic retransmission: Отключение автоматического повторного отправления. |
|        |       | - 0: Автоматическое повторное отправление включено. |
|        |       | - 1: Автоматическое повторное отправление отключено. |
| 5      | MON   | Bus monitoring mode: Режим мониторинга шины. |
|        |       | - 0: Режим мониторинга шины отключен. |
|        |       | - 1: Режим мониторинга шины включен. |
| 4      | CSR   | Clock stop request: Запрос остановки тактового сигнала. |
|        |       | - 0: Остановка тактового сигнала не запрошена. |
|        |       | - 1: Запрос на остановку тактового сигнала. Когда запрошена остановка тактового сигнала, сначала устанавливается INIT, а затем CSA после завершения всех ожидающих запросов передачи и перехода шины CAN в состояние покоя. |
| 3      | CSA   | Clock stop acknowledge: Подтверждение остановки тактового сигнала. |
|        |       | - 0: Остановка тактового сигнала не подтверждена. |
|        |       | - 1: FDCAN может быть переведен в режим пониженного энергопотребления путем остановки тактового сигнала APB и ядра. |
| 2      | ASM   | ASM restricted operation mode: Ограниченный режим работы. |
|        |       | - 0: Нормальная работа CAN. |
|        |       | - 1: Ограниченный режим работы активен. |
| 1      | CCE   | Configuration change enable: Разрешение изменения конфигурации. |
|        |       | - 0: ЦПУ не имеет доступа на запись к защищенным конфигурационным регистрам. |
|        |       | - 1: ЦПУ имеет доступ на запись к защищенным конфигурационным регистрам (при установленном значении INIT в регистре FDCAN_CCCR). |
| 0      | INIT  | Initialization: Инициализация модуля FDCAN. |
|        |       | - 0: Нормальная работа. |
|        |       | - 1: Инициализация начата. |

### Пример кода на низком уровне (без HAL) для изменения конфигурации FDCAN

```c
#define FDCAN_CCCR      (*(volatile uint32_t*)(0x40006418))

void FDCAN_Config(void) {
    // Включение инициализации и разрешение изменения конфигурации
    FDCAN_CCCR |= (1 << 0) | (1 << 1); // Установка битов INIT и CCE

    // Ожидание установки битов
    while (!(FDCAN_CCCR & (1 << 0)) || !(FDCAN_CCCR & (1 << 1)));

    // Настройка регистра FDCAN_CCCR
    FDCAN_CCCR |= (1 << 8);  // Включение режима FD (FDOE)
    FDCAN_CCCR |= (1 << 9);  // Включение переключения скорости передачи (BRSE)
    FDCAN_CCCR &= ~(1 << 7); // Отключение тестового режима (TEST)
    FDCAN_CCCR &= ~(1 << 12); // Включение обработки исключений протокола (PXHD)
    FDCAN_CCCR &= ~(1 << 15); // Использование формата кадров CAN FD по ISO11898-1 (NISO)

    // Завершение инициализации
    FDCAN_CCCR &= ~((1 << 0) | (1 << 1)); // Сброс битов INIT и CCE

    // Ожидание сброса битов
    while ((FDCAN_CCCR & (1 << 0)) || (FDCAN_CCCR & (1 << 1)));
}

int main(void) {
    // Настройка системного тактирования (предполагается, что уже настроено)

    // Настройка FDCAN
    FDCAN_Config();

    // Основной цикл программы
    while (1) {
        // Ваш код здесь
    }
}

void Error_Handler(void) {
    // Обработка ошибок
    __disable_irq();
    while (1) {
    }
}
```

### Объяснение кода:

1. **FDCAN_Config()**:
   - Включает инициализацию и разрешает изменение конфигурации модуля FDCAN.
   - Ждет установки битов INIT и CCE.
   - Настраивает регистр FDCAN_CCCR для включения режима FD, переключения скорости передачи, отключения тестового режима и использования формата кадров CAN FD по ISO11898-1.
   - Завершает инициализацию, сбрасывая биты INIT и CCE.
   - Ждет сброса битов INIT и CCE.

2. **main()**:
   - Настраивает системное тактирование (предполагается, что уже настроено).
   - Настраивает FDCAN.
   - Входит в основной цикл программы.

Этот пример демонстрирует, как настроить регистр FDCAN_CCCR на низком уровне без использования библиотеки HAL, обеспечивая гибкость и контроль над конфигурацией модуля FDCAN.



Понял, давайте сосредоточимся на необходимых изменениях в регистре FDCAN_CCCR и удалим лишний код, который оставляет установки по умолчанию без изменений.

Регистр управления FDCAN CC (FDCAN_CCCR)
Регистр управления FDCAN CC (FDCAN_CCCR) используется для настройки различных параметров и режимов работы модуля FDCAN. Этот регистр имеет смещение адреса 0x0018 и значение по умолчанию 0x0000 0001 после сброса.

Описание полей регистра FDCAN_CCCR
31:16		Зарезервировано, должно быть установлено в значение по умолчанию.
15	NISO	Non-ISO operation: Использование формата кадров CAN FD, как указано в спецификации Bosch CAN FD V1.0.
- 0: Формат кадров CAN FD согласно ISO11898-1.
- 1: Формат кадров CAN FD согласно спецификации Bosch CAN FD V1.0.
14	TXP	Transmit pause enable: Включение паузы перед следующей передачей после успешной передачи кадра.
- 0: Отключено.
- 1: Включено (пауза на два CAN бита перед следующей передачей).
13	EFBI	Edge filtering during bus integration: Фильтрация фронтов при интеграции на шине.
- 0: Фильтрация фронтов отключена.
- 1: Для обнаружения фронта требуется два последовательных доминантных tq.
12	PXHD	Protocol exception handling disable: Отключение обработки исключений протокола.
- 0: Обработка исключений протокола включена.
- 1: Обработка исключений протокола отключена.
11:10		Зарезервировано, должно быть установлено в значение по умолчанию.
9	BRSE	FDCAN bit rate switching: Переключение скорости передачи для FDCAN.
- 0: Переключение скорости передачи отключено.
- 1: Переключение скорости передачи включено.
8	FDOE	FD operation enable: Включение работы в режиме FD.
- 0: Работа в режиме FD отключена.
- 1: Работа в режиме FD включена.
7	TEST	Test mode enable: Включение тестового режима.
- 0: Нормальная работа, регистр FDCAN_TEST удерживает значения по умолчанию.
- 1: Тестовый режим, разрешен доступ на запись в регистр FDCAN_TEST.
6	DAR	Disable automatic retransmission: Отключение автоматического повторного отправления.
- 0: Автоматическое повторное отправление включено.
- 1: Автоматическое повторное отправление отключено.
5	MON	Bus monitoring mode: Режим мониторинга шины.
- 0: Режим мониторинга шины отключен.
- 1: Режим мониторинга шины включен.
4	CSR	Clock stop request: Запрос остановки тактового сигнала.
- 0: Остановка тактового сигнала не запрошена.
- 1: Запрос на остановку тактового сигнала. Когда запрошена остановка тактового сигнала, сначала устанавливается INIT, а затем CSA после завершения всех ожидающих запросов передачи и перехода шины CAN в состояние покоя.
3	CSA	Clock stop acknowledge: Подтверждение остановки тактового сигнала.
- 0: Остановка тактового сигнала не подтверждена.
- 1: FDCAN может быть переведен в режим пониженного энергопотребления путем остановки тактового сигнала APB и ядра.
2	ASM	ASM restricted operation mode: Ограниченный режим работы.
- 0: Нормальная работа CAN.
- 1: Ограниченный режим работы активен.
1	CCE	Configuration change enable: Разрешение изменения конфигурации.
- 0: ЦПУ не имеет доступа на запись к защищенным конфигурационным регистрам.
- 1: ЦПУ имеет доступ на запись к защищенным конфигурационным регистрам (при установленном значении INIT в регистре FDCAN_CCCR).
0	INIT	Initialization: Инициализация модуля FDCAN.
- 0: Нормальная работа.
- 1: Инициализация начата.
Пример кода на низком уровне (без HAL) для изменения конфигурации FDCAN
C
#define FDCAN_CCCR      (*(volatile uint32_t*)(0x40006418))

void FDCAN_Config(void) {
    // Включение инициализации и разрешение изменения конфигурации
    FDCAN_CCCR |= (1 << 0) | (1 << 1); // Установка битов INIT и CCE

    // Ожидание установки битов
    while (!(FDCAN_CCCR & (1 << 0)) || !(FDCAN_CCCR & (1 << 1)));

    // Настройка регистра FDCAN_CCCR
    FDCAN_CCCR |= (1 << 8);  // Включение режима FD (FDOE)
    FDCAN_CCCR |= (1 << 9);  // Включение переключения скорости передачи (BRSE)
    // Отключение тестового режима не требуется, так как он уже отключен по умолчанию (TEST = 0)
    // Включение обработки исключений протокола не требуется, так как она уже включена по умолчанию (PXHD = 0)
    // Использование формата кадров CAN FD по ISO11898-1 не требуется, так как это значение по умолчанию (NISO = 0)

    // Завершение инициализации
    FDCAN_CCCR &= ~((1 << 0) | (1 << 1)); // Сброс битов INIT и CCE

    // Ожидание сброса битов
    while ((FDCAN_CCCR & (1 << 0)) || (FDCAN_CCCR & (1 << 1)));
}

int main(void) {
    // Настройка системного тактирования (предполагается, что уже настроено)

    // Настройка FDCAN
    FDCAN_Config();

    // Основной цикл программы
    while (1) {
        // Ваш код здесь
    }
}

void Error_Handler(void) {
    // Обработка ошибок
    __disable_irq();
    while (1) {
    }
}
Объяснение кода:
FDCAN_Config():

Включает инициализацию и разрешает изменение конфигурации модуля FDCAN.
Ждет установки битов INIT и CCE.
Настраивает регистр FDCAN_CCCR для включения режима FD (FDOE) и переключения скорости передачи (BRSE).
Завершает инициализацию, сбрасывая биты INIT и CCE.
Ждет сброса битов INIT и CCE.
main():

Настраивает системное тактирование (предполагается, что уже настроено).
Настраивает FDCAN.
Входит в основной цикл программы.
Этот пример демонстрирует, как настроить регистр FDCAN_CCCR на низком уровне без использования библиотеки HAL, обеспечивая гибкость и контроль над конфигурацией модуля FDCAN, и устраняя лишний код, который оставляет настройки по умолчанию без изменений.


Если частота микроконтроллера STM32G431 составляет 150 МГц, вам нужно будет пересчитать параметры регистра FDCAN_NBTP, чтобы настроить модуль FDCAN для работы с желаемой битовой скоростью. Давайте рассмотрим, как это сделать.

### Пояснение

Частота ядра FDCAN (fdcan_ker_ck) влияет на вычисление временных параметров битового тайминга. Важно выбрать правильные значения для полей NBRP, NTSEG1, NTSEG2 и NSJW, чтобы добиться нужной битовой скорости.

#### Пример настройки для битовой скорости 500 кбит/с

Допустим, мы хотим настроить FDCAN для работы с битовой скоростью 500 кбит/с при частоте ядра FDCAN в 150 МГц. 

- **tq (Time Quantum)**: время кванта (tq) можно вычислить как (NBRP + 1) * (1 / 150 МГц).
- **Битовое время**: общее битовое время состоит из [SYNC_SEG + PROP_SEG + PHASE_SEG1 + PHASE_SEG2] * tq.

Для битовой скорости 500 кбит/с битовое время должно быть 2 мкс (1 / 500 кГц).

### Расчеты

1. Выберем значение NBRP:
   \[
   tq = (NBRP + 1) \times \frac{1}{150 \text{ МГц}}
   \]
   Пусть NBRP = 14:
   \[
   tq = (14 + 1) \times \frac{1}{150 \text{ МГц}} = 15 \times \frac{1}{150 \text{ МГц}} = 100 \text{ нс}
   \]

2. Рассчитаем общее количество квантов для битового времени:
   \[
   \text{Битовое время} = 2 \text{ мкс} = 2000 \text{ нс}
   \]
   \[
   \text{Общее количество квантов} = \frac{2000 \text{ нс}}{100 \text{ нс}} = 20 квантов
   \]

3. Разделим общее количество квантов между сегментами:
   - SYNC_SEG = 1 tq (фиксированное значение)
   - PROP_SEG + PHASE_SEG1 = NTSEG1 + 1 квант
   - PHASE_SEG2 = NTSEG2 + 1 квант

   Пусть NTSEG1 = 12 квантов, NTSEG2 = 6 квантов:
   - NTSEG1 (PROP_SEG + PHASE_SEG1) = 12 квантов
   - NTSEG2 (PHASE_SEG2) = 6 квантов

### Пример кода для настройки FDCAN_NBTP:

```c
#define FDCAN_CCCR      (*(volatile uint32_t*)(0x40006418))
#define FDCAN_NBTP      (*(volatile uint32_t*)(0x4000641C))

void FDCAN_Config(void) {
    // Включение инициализации и разрешение изменения конфигурации
    FDCAN_CCCR |= (1 << 0) | (1 << 1); // Установка битов INIT и CCE

    // Ожидание установки битов
    while (!(FDCAN_CCCR & (1 << 0)) || !(FDCAN_CCCR & (1 << 1)));

    // Настройка регистра FDCAN_NBTP для битовой скорости 500 кбит/с
    // При частоте ядра CAN 150 МГц
    // tq = (NBRP + 1) * (1 / 150 МГц) = 100 нс
    // Общее битовое время = 20 tq = 2000 нс = 2 мкс
    // NTSEG1 = 12, NTSEG2 = 6, NSJW = 3 (например)

    uint32_t nbtp_value = (3 << 25) |  // NSJW = 3
                          (14 << 16) | // NBRP = 14
                          (12 << 8) |  // NTSEG1 = 12
                          (6);         // NTSEG2 = 6

    FDCAN_NBTP = nbtp_value;

    // Завершение инициализации
    FDCAN_CCCR &= ~((1 << 0) | (1 << 1)); // Сброс битов INIT и CCE

    // Ожидание сброса битов
    while ((FDCAN_CCCR & (1 << 0)) || (FDCAN_CCCR & (1 << 1)));
}

int main(void) {
    // Настройка системного тактирования (предполагается, что уже настроено)

    // Настройка FDCAN
    FDCAN_Config();

    // Основной цикл программы
    while (1) {
        // Ваш код здесь
    }
}

void Error_Handler(void) {
    // Обработка ошибок
    __disable_irq();
    while (1) {
    }
}
```

### Заключение

Этот пример демонстрирует, как настроить регистр FDCAN_NBTP для достижения битовой скорости 500 кбит/с при частоте ядра FDCAN в 150 МГц. Выбранные значения для NBRP, NTSEG1, NTSEG2 и NSJW обеспечивают правильное битовое время для достижения требуемой скорости передачи данных.


### Регистр конфигурации счетчика метки времени (FDCAN_TSCC)

Регистр конфигурации счетчика метки времени (FDCAN_TSCC) используется для настройки параметров счетчика метки времени в модуле FDCAN. Этот регистр имеет смещение адреса 0x0020 и значение по умолчанию 0x0000 0000 после сброса.

#### Описание полей регистра FDCAN_TSCC

| Бит    | Поле  | Описание                                                                                      |
|--------|-------|-----------------------------------------------------------------------------------------------|
| 31:20  |       | Зарезервировано, должно быть установлено в значение по умолчанию.                             |
| 19:16  | TCP   | Timestamp counter prescaler: Предделитель счетчика метки времени                               |
|        |       | - Конфигурирует единицу времени счетчика метки времени и таймера таймаута в кратных CAN битов  |
|        |       | - Допустимые значения: 0 - 15.                                                                |
|        |       | - Фактическое значение: запрограммированное значение + 1.                                     |
|        |       | - В режиме CAN FD требуется внешний счетчик для генерации метки времени (TSS[1:0] = 10).      |
| 15:2   |       | Зарезервировано, должно быть установлено в значение по умолчанию.                             |
| 1:0    | TSS   | Timestamp select: Выбор источника метки времени                                                |
|        |       | - 00: Значение счетчика метки времени всегда 0x0000                                           |
|        |       | - 01: Значение счетчика метки времени увеличивается в соответствии с TCP                      |
|        |       | - 10: Внешний счетчик метки времени из значения TIM3 (tim3_cnt[0:15])                         |
|        |       | - 11: То же, что и 00.                                                                        |

### Регистр значения счетчика метки времени (FDCAN_TSCV)

Регистр значения счетчика метки времени (FDCAN_TSCV) используется для чтения или сброса текущего значения счетчика метки времени. Этот регистр имеет смещение адреса 0x0024 и значение по умолчанию 0x0000 0000 после сброса.

#### Описание полей регистра FDCAN_TSCV

| Бит    | Поле  | Описание                                                                                         |
|--------|-------|--------------------------------------------------------------------------------------------------|
| 31:16  |       | Зарезервировано, должно быть установлено в значение по умолчанию.                                |
| 15:0   | TSC   | Timestamp counter: Значение счетчика метки времени                                                |
|        |       | - Внутренний/внешний счетчик метки времени захватывается при начале кадра (как Rx, так и Tx).      |
|        |       | - При TSS[1:0] = 01 счетчик метки времени увеличивается в кратных CAN битов в зависимости от TCP. |
|        |       | - Запись в этот регистр сбрасывает счетчик в 0.                                                   |
|        |       | - При TSS[1:0] = 10 TSC[15:0] отражает значение внешнего счетчика метки времени. Запись в этот    |
|        |       |   регистр не влияет на счетчик.                                                                   |
|        |       | - "Переполнение" происходит, когда значение счетчика метки времени меняется с ненулевого на 0,    |
|        |       |   не из-за записи в FDCAN_TSCV.                                                                   |

### Пример настройки регистров FDCAN_TSCC и FDCAN_TSCV:

Допустим, мы хотим настроить счетчик метки времени для увеличения значения в каждом CAN битовом времени и использовать внутренний счетчик метки времени.

Пример кода для настройки регистра FDCAN_TSCC и работы с регистром FDCAN_TSCV:

```c
#define FDCAN_CCCR      (*(volatile uint32_t*)(0x40006418))
#define FDCAN_TSCC      (*(volatile uint32_t*)(0x40006420))
#define FDCAN_TSCV      (*(volatile uint32_t*)(0x40006424))

void FDCAN_Config(void) {
    // Включение инициализации и разрешение изменения конфигурации
    FDCAN_CCCR |= (1 << 0) | (1 << 1); // Установка битов INIT и CCE

    // Ожидание установки битов
    while (!(FDCAN_CCCR & (1 << 0)) || !(FDCAN_CCCR & (1 << 1)));

    // Настройка регистра FDCAN_TSCC для использования внутреннего счетчика метки времени
    // и увеличения значения в каждом CAN битовом времени (TCP = 0)
    uint32_t tscc_value = (0 << 16) |  // TCP = 0 (единица времени счетчика равна 1 CAN битовому времени)
                          (1 << 0);    // TSS = 01 (внутренний счетчик метки времени)

    FDCAN_TSCC = tscc_value;

    // Сброс счетчика метки времени
    FDCAN_TSCV = 0;

    // Завершение инициализации
    FDCAN_CCCR &= ~((1 << 0) | (1 << 1)); // Сброс битов INIT и CCE

    // Ожидание сброса битов
    while ((FDCAN_CCCR & (1 << 0)) || (FDCAN_CCCR & (1 << 1)));
}

int main(void) {
    // Настройка системного тактирования (предполагается, что уже настроено)

    // Настройка FDCAN
    FDCAN_Config();

    // Основной цикл программы
    while (1) {
        // Ваш код здесь

        // Пример чтения значения счетчика метки времени
        uint32_t timestamp = FDCAN_TSCV;
        // Обработка значения таймстампа
    }
}

void Error_Handler(void) {
    // Обработка ошибок
    __disable_irq();
    while (1) {
    }
}
```

### Объяснение кода:

1. **FDCAN_Config()**:
   - Включает инициализацию и разрешает изменение конфигурации модуля FDCAN.
   - Ждет установки битов INIT и CCE.
   - Настраивает регистр FDCAN_TSCC для использования внутреннего счетчика метки времени и увеличения значения в каждом CAN битовом времени.
   - Сбрасывает счетчик метки времени.
   - Завершает инициализацию, сбрасывая биты INIT и CCE.
   - Ждет сброса битов INIT и CCE.

2. **main()**:
   - Настраивает системное тактирование (предполагается, что уже настроено).
   - Настраивает FDCAN.
   - В основном цикле программы выполняется чтение значения счетчика метки времени для дальнейшей обработки.

Этот пример демонстрирует, как настроить и использовать регистры FDCAN_TSCC и FDCAN_TSCV, обеспечивая гибкость и контроль над конфигурацией модуля FDCAN.

### Регистр счетчика ошибок FDCAN (FDCAN_ECR)

Регистр счетчика ошибок FDCAN (FDCAN_ECR) используется для мониторинга ошибок в передаче и приеме данных в модуле FDCAN (Flexible Data-Rate Controller Area Network). Этот регистр имеет смещение адреса 0x0040 и значение по умолчанию 0x0000 0000 после сброса.

#### Описание полей регистра FDCAN_ECR

| Бит    | Поле  | Описание                                                                                      |
|--------|-------|-----------------------------------------------------------------------------------------------|
| 31:24  |       | Зарезервировано, должно быть установлено в значение по умолчанию.                             |
| 23:16  | CEL   | CAN error logging: Журналирование ошибок CAN                                                  |
|        |       | - Счетчик увеличивается каждый раз, когда ошибка протокола CAN вызывает увеличение счетчика ошибок передачи (TEC) или ошибок приема (REC). |
|        |       | - Счетчик сбрасывается при чтении поля CEL[7:0].                                              |
|        |       | - Счетчик останавливается на значении 0xFF; следующее увеличение TEC или REC устанавливает флаг прерывания ELO в регистре FDCAN_IR. |
|        |       | - Тип доступа rc_r: сбрасывается при чтении.                                                  |
| 15     | RP    | Receive error passive: Пассивная ошибка приема                                                |
|        |       | - 0: Счетчик ошибок приема ниже уровня пассивной ошибки (128).                                 |
|        |       | - 1: Счетчик ошибок приема достиг уровня пассивной ошибки (128).                              |
| 14:8   | REC   | Receive error counter: Счетчик ошибок приема                                                  |
|        |       | - Текущее состояние счетчика ошибок приема, значения от 0 до 127.                             |
| 7:0    | TEC   | Transmit error counter: Счетчик ошибок передачи                                               |
|        |       | - Текущее состояние счетчика ошибок передачи, значения от 0 до 255.                           |
|        |       | - Когда бит ASM регистра FDCAN_CCCR установлен, контроллер протокола CAN не увеличивает TEC и REC при обнаружении ошибки протокола CAN, но CEL[7:0] все равно увеличивается. |

### Пример использования регистра FDCAN_ECR

Рассмотрим пример кода для чтения значений счетчиков ошибок и журнала ошибок из регистра FDCAN_ECR.

Пример кода для чтения регистра FDCAN_ECR:

```c
#define FDCAN_ECR      (*(volatile uint32_t*)(0x40006440))

void read_FDCAN_ECR(void) {
    uint32_t ecr_value = FDCAN_ECR;

    // Извлечение значений полей из регистра
    uint8_t CEL = (ecr_value >> 16) & 0xFF; // Журнал ошибок CAN
    uint8_t RP = (ecr_value >> 15) & 0x01;  // Пассивная ошибка приема
    uint8_t REC = (ecr_value >> 8) & 0x7F;  // Счетчик ошибок приема
    uint8_t TEC = ecr_value & 0xFF;         // Счетчик ошибок передачи

    // Вывод значений
    printf("CEL: %u\n", CEL);
    printf("RP: %u\n", RP);
    printf("REC: %u\n", REC);
    printf("TEC: %u\n", TEC);

    // Чтение регистра сбрасывает счетчик ошибок CEL
    uint32_t ecr_value_after_read = FDCAN_ECR;
    uint8_t CEL_after_read = (ecr_value_after_read >> 16) & 0xFF;
    printf("CEL after read: %u\n", CEL_after_read);
}

int main(void) {
    // Настройка системного тактирования (предполагается, что уже настроено)

    // Основной цикл программы
    while (1) {
        // Чтение значений счетчиков ошибок
        read_FDCAN_ECR();

        // Задержка для демонстрации периодического чтения (например, 1 секунда)
        HAL_Delay(1000);
    }
}

void Error_Handler(void) {
    // Обработка ошибок
    __disable_irq();
    while (1) {
    }
}
```

### Объяснение кода:

1. **read_FDCAN_ECR()**:
   - Считывает значение регистра FDCAN_ECR.
   - Извлекает значения полей CEL, RP, REC и TEC из регистра.
   - Выводит значения на консоль.
   - Чтение регистра сбрасывает счетчик ошибок CEL.
   - Считывает и выводит значение CEL после чтения, чтобы показать, что оно было сброшено.

2. **main()**:
   - Настраивает системное тактирование (предполагается, что уже настроено).
   - В основном цикле программы периодически вызывает функцию read_FDCAN_ECR() для чтения значений счетчиков ошибок и вывода их на консоль.

Этот пример демонстрирует, как использовать регистр FDCAN_ECR для мониторинга ошибок в передаче и приеме данных в модуле FDCAN, а также как интерпретировать значения счетчиков ошибок.


### Регистр состояния протокола FDCAN (FDCAN_PSR)

Регистр состояния протокола FDCAN (FDCAN_PSR) используется для мониторинга текущего состояния протокола CAN и отслеживания ошибок, произошедших на CAN шине. Этот регистр имеет смещение адреса 0x0044 и значение по умолчанию 0x0000 0707 после сброса.

#### Описание полей регистра FDCAN_PSR

| Бит    | Поле   | Описание                                                                                      |
|--------|--------|-----------------------------------------------------------------------------------------------|
| 31:23  |        | Зарезервировано, должно быть установлено в значение по умолчанию.                             |
| 22:16  | TDCV   | Transmitter delay compensation value: Значение компенсации задержки передачи                  |
|        |        | - Положение вторичной точки выборки, определяемое суммой измеренной задержки от FDCAN_TX до FDCAN_RX и TDCO[6:0] в FDCAN_TDCR. |
|        |        | - Допустимые значения: 0 - 127 × минимальное время кванта (mtq).                              |
| 15     |        | Зарезервировано, должно быть установлено в значение по умолчанию.                             |
| 14     | PXE    | Protocol exception event: Событие исключения протокола                                        |
|        |        | - 0: Событие исключения протокола не произошло с момента последнего чтения.                   |
|        |        | - 1: Событие исключения протокола произошло.                                                  |
| 13     | REDL   | Received FDCAN message: Принятое сообщение FDCAN                                              |
|        |        | - 0: Сообщение в формате FDCAN с установленным флагом EDL не было принято.                    |
|        |        | - 1: Сообщение в формате FDCAN с установленным флагом EDL было принято.                      |
| 12     | RBRS   | BRS flag of last received FDCAN message: Флаг BRS последнего принятого сообщения FDCAN        |
|        |        | - 0: Последнее принятое сообщение FDCAN не имело установленного флага BRS.                    |
|        |        | - 1: Последнее принятое сообщение FDCAN имело установленный флаг BRS.                        |
| 11     | RESI   | ESI flag of last received FDCAN message: Флаг ESI последнего принятого сообщения FDCAN        |
|        |        | - 0: Последнее принятое сообщение FDCAN не имело установленного флага ESI.                    |
|        |        | - 1: Последнее принятое сообщение FDCAN имело установленный флаг ESI.                        |
| 10:8   | DLEC   | Data last error code: Последний код ошибки данных                                              |
|        |        | - Тип последней ошибки, произошедшей в фазе данных кадра формата FDCAN с установленным флагом BRS. |
|        |        | - Кодирование такое же, как для LEC[2:0].                                                     |
|        |        | - Поле сбрасывается при успешной передаче или приеме кадра формата FDCAN с установленным флагом BRS без ошибок. |
| 7      | BO     | Bus-off status: Состояние отключения шины                                                     |
|        |        | - 0: FDCAN не находится в состоянии отключения шины.                                          |
|        |        | - 1: FDCAN находится в состоянии отключения шины.                                             |
| 6      | EW     | Warning status: Состояние предупреждения                                                      |
|        |        | - 0: Оба счетчика ошибок ниже предела предупреждения об ошибках (96).                         |
|        |        | - 1: По крайней мере один из счетчиков ошибок достиг предела предупреждения об ошибках (96).  |
| 5      | EP     | Error passive: Пассивная ошибка                                                               |
|        |        | - 0: FDCAN находится в состоянии активной ошибки.                                             |
|        |        | - 1: FDCAN находится в состоянии пассивной ошибки.                                            |
| 4:3    | ACT    | Activity: Активность                                                                           |
|        |        | - 00: Синхронизация: узел синхронизируется на CAN связи.                                      |
|        |        | - 01: Ожидание: узел не является ни приемником, ни передатчиком.                              |
|        |        | - 10: Приемник: узел работает как приемник.                                                   |
|        |        | - 11: Передатчик: узел работает как передатчик.                                               |
| 2:0    | LEC    | Last error code: Последний код ошибки                                                         |
|        |        | - LEC[2:0] указывает тип последней ошибки, произошедшей на шине CAN.                          |
|        |        | - Это поле сбрасывается при успешной передаче или приеме сообщения без ошибок.                 |
|        |        | - 000: Ошибок не произошло с момента сброса поля LEC[2:0] после успешной передачи или приема. |
|        |        | - 001: Ошибка заполнения. Произошло более пяти одинаковых битов в последовательности в части принятого сообщения, где это не разрешено. |
|        |        | - 010: Ошибка формата. Фиксированный формат части принятого кадра имеет неправильный формат.  |
|        |        | - 011: Ошибка подтверждения. Сообщение, переданное FDCAN, не было подтверждено другим узлом.  |
|        |        | - 100: Ошибка бита 1. Во время передачи сообщения (за исключением поля арбитража) устройство хотело передать рецессивный уровень (логическое значение 1), но наблюдаемое значение шины было доминантным. |
|        |        | - 101: Ошибка бита 0. Во время передачи сообщения (или бита подтверждения, или активного флага ошибки, или флага перегрузки) устройство хотело передать доминантный уровень (логическое значение 0), но наблюдаемое значение шины было рецессивным. |
|        |        | - 110: Ошибка CRC. Контрольная сумма CRC принятого сообщения была некорректной. CRC принятого сообщения не совпадает с CRC, рассчитанным из принятых данных. |
|        |        | - 111: Нет изменений. Любой доступ на чтение к регистру состояния протокола сбрасывает LEC[2:0] на 7. |
|        |        | - При значении LEC[2:0] равном 7, событие на шине CAN не было обнаружено с момента последнего чтения регистра состояния протокола. |

### Пример использования регистра FDCAN_PSR

Рассмотрим пример кода для чтения значений из регистра FDCAN_PSR и вывода их на консоль.

Пример кода для чтения регистра FDCAN_PSR:

```c
#define FDCAN_PSR      (*(volatile uint32_t*)(0x40006444))

void read_FDCAN_PSR(void) {
    uint32_t psr_value = FDCAN_PSR;

    // Извлечение значений полей из регистра
    uint8_t TDCV = (psr_value >> 16) & 0x7F; // Значение компенсации задержки передачи
    uint8_t PXE = (psr_value >> 14) & 0x01;  // Событие исключения протокола
    uint8_t REDL = (psr_value >> 13) & 0x01; // Принятое сообщение FDCAN
    uint8_t RBRS = (psr_value >> 12) & 0x01; // Флаг BRS последнего принятого сообщения FDCAN
    uint8_t RESI = (psr_value >> 11) & 0x01; // Флаг ESI последнего принятого сообщения FDCAN
    uint8_t DLEC = (psr_value >> 8) & 0x07;  // Последний код ошибки данных
    uint8_t BO = (psr_value >> 7) & 0x01;    // Состояние отключения шины
    uint8_t EW = (psr_value >> 6) & 0x01;    // Состояние предупреждения
    uint8_t EP = (psr_value >> 5) & 0x01;    // Пассивная ошибка
    uint8_t ACT = (psr_value >> 3) & 0x03;   // Активность
    uint8_t LEC = psr_value & 0x07;          // Последний код ошибки

    // Вывод значений
    printf("TDCV: %u\n", TDCV);
    printf("PXE: %u\n", PXE);
    printf("REDL: %u\n", REDL);
    printf("RBRS: %u\n", RBRS);
    printf("RESI: %u\n", RESI);
    printf("DLEC: %u\n", DLEC);
    printf("BO: %u\n", BO);
    printf("EW: %u\n", EW);
    printf("EP: %u\n", EP);
    printf("ACT: %u\n", ACT);
    printf("LEC: %u\n", LEC);

    // Интерпретация кода последней ошибки
    switch (LEC) {
        case 0:
            printf("No error occurred since the last read.\n");
            break;
        case 1:
            printf("Stuff error: more than five equal bits in a sequence.\n");
            break;
        case 2:
            printf("Form error: fixed format part of a received frame has the wrong format.\n");
            break;
        case 3:
            printf("Ack error: the message was not acknowledged by another node.\n");
            break;
        case 4:
            printf("Bit1 error: sent recessive level, but monitored bus value was dominant.\n");
            break;
        case 5:
            printf("Bit0 error: sent dominant level, but monitored bus value was recessive.\n");
            break;
        case 6:
            printf("CRC error: the CRC check sum was incorrect.\n");
            break;
        case 7:
            printf("No change: no CAN bus event was detected since the last read.\n");
            break;
        default:
            printf("Unknown error code.\n");
            break;
    }
}

int main(void) {
    // Настройка системного тактирования (предполагается, что уже настроено)

    // Основной цикл программы
    while (1) {
        // Чтение значений состояния протокола
        read_FDCAN_PSR();

        // Задержка для демонстрации периодического чтения (например, 1 секунда)
        HAL_Delay(1000);
    }
}

void Error_Handler(void) {
    // Обработка ошибок
    __disable_irq();
    while (1) {
    }
}
```

### Объяснение кода:

1. **read_FDCAN_PSR()**:
   - Считывает значение регистра FDCAN_PSR.
   - Извлекает значения полей TDCV, PXE, REDL, RBRS, RESI, DLEC, BO, EW, EP, ACT и LEC из регистра.
   - Выводит значения на консоль.
   - Интерпретирует и выводит описание последнего кода ошибки (LEC).

2. **main()**:
   - Настраивает системное тактирование (предполагается, что уже настроено).
   - В основном цикле программы периодически вызывает функцию read_FDCAN_PSR() для чтения значений состояния протокола и вывода их на консоль.

Этот пример демонстрирует, как использовать регистр FDCAN_PSR для мониторинга текущего состояния протокола CAN и отслеживания ошибок, произошедших на CAN шине, а также как интерпретировать значения полей регистра.


### Регистр прерываний FDCAN (FDCAN_IR)

Регистр прерываний FDCAN (FDCAN_IR) используется для индикации различных событий и условий, которые могут вызвать прерывания в модуле FDCAN. Флаги в этом регистре устанавливаются, когда обнаруживается одно из перечисленных условий (чувствительность к фронту). Флаги остаются установленными до тех пор, пока хост не очистит их. Флаг очищается записью 1 в соответствующую позицию бита. Запись 0 не оказывает влияния. Жесткий сброс очищает регистр. Конфигурация FDCAN_IE контролирует, генерируется ли прерывание. Конфигурация FDCAN_ILS контролирует, на какой линии прерывания сигнализируется прерывание.

#### Описание полей регистра FDCAN_IR

| Бит    | Поле | Описание                                                                                      |
|--------|------|-----------------------------------------------------------------------------------------------|
| 31:24  |      | Зарезервировано, должно быть установлено в значение по умолчанию.                             |
| 23     | ARA  | Access to reserved address: Доступ к зарезервированному адресу                                |
|        |      | - 0: Доступ к зарезервированному адресу не произошел.                                         |
|        |      | - 1: Доступ к зарезервированному адресу произошел.                                            |
| 22     | PED  | Protocol error in data phase: Ошибка протокола в фазе данных                                  |
|        |      | - 0: Ошибок протокола в фазе данных не было.                                                  |
|        |      | - 1: Обнаружена ошибка протокола в фазе данных (DLEC[2:0] отличается от 0 и 7 в FDCAN_PSR).   |
| 21     | PEA  | Protocol error in arbitration phase: Ошибка протокола в фазе арбитража                        |
|        |      | - 0: Ошибок протокола в фазе арбитража не было.                                               |
|        |      | - 1: Обнаружена ошибка протокола в фазе арбитража (LEC[2:0] отличается от 0 и 7 в FDCAN_PSR). |
| 20     | WDI  | Watchdog interrupt: Прерывание сторожевого таймера                                            |
|        |      | - 0: События сторожевого таймера RAM не было.                                                 |
|        |      | - 1: Событие сторожевого таймера RAM из-за отсутствия READY.                                  |
| 19     | BO   | Bus-off status: Состояние отключения шины                                                     |
|        |      | - 0: Состояние отключения шины не изменилось.                                                 |
|        |      | - 1: Состояние отключения шины изменилось.                                                    |
| 18     | EW   | Warning status: Состояние предупреждения                                                      |
|        |      | - 0: Состояние предупреждения об ошибке не изменилось.                                        |
|        |      | - 1: Состояние предупреждения об ошибке изменилось.                                           |
| 17     | EP   | Error passive: Пассивная ошибка                                                               |
|        |      | - 0: Состояние пассивной ошибки не изменилось.                                                |
|        |      | - 1: Состояние пассивной ошибки изменилось.                                                   |
| 16     | ELO  | Error logging overflow: Переполнение журнала ошибок                                           |
|        |      | - 0: Переполнения журнала ошибок CAN не было.                                                 |
|        |      | - 1: Произошло переполнение журнала ошибок CAN.                                               |
| 15     | TOO  | Timeout occurred: Произошел тайм-аут                                                          |
|        |      | - 0: Тайм-аута не было.                                                                       |
|        |      | - 1: Тайм-аут достигнут.                                                                      |
| 14     | MRAF | Message RAM access failure: Ошибка доступа к RAM сообщения                                    |
|        |      | - 0: Ошибок доступа к RAM сообщения не было.                                                  |
|        |      | - 1: Произошла ошибка доступа к RAM сообщения.                                                |
| 13     | TSW  | Timestamp wraparound: Переполнение счетчика метки времени                                     |
|        |      | - 0: Переполнения счетчика метки времени не было.                                             |
|        |      | - 1: Счетчик метки времени переполнен.                                                        |
| 12     | TEFL | Tx event FIFO element lost: Элемент FIFO события передачи потерян                             |
|        |      | - 0: Элемент FIFO события передачи не потерян.                                                |
|        |      | - 1: Элемент FIFO события передачи потерян.                                                   |
| 11     | TEFF | Tx event FIFO full: FIFO события передачи полон                                               |
|        |      | - 0: FIFO события передачи не полон.                                                          |
|        |      | - 1: FIFO события передачи полон.                                                             |
| 10     | TEFN | Tx event FIFO new entry: Новый элемент FIFO события передачи                                  |
|        |      | - 0: FIFO события передачи не изменен.                                                        |
|        |      | - 1: Обработчик передачи записал элемент FIFO события передачи.                               |
| 9      | TFE  | Tx FIFO empty: FIFO передачи пуст                                                             |
|        |      | - 0: FIFO передачи не пуст.                                                                   |
|        |      | - 1: FIFO передачи пуст.                                                                      |
| 8      | TCF  | Transmission cancellation finished: Завершение отмены передачи                                |
|        |      | - 0: Отмена передачи не завершена.                                                            |
|        |      | - 1: Отмена передачи завершена.                                                               |
| 7      | TC   | Transmission completed: Передача завершена                                                    |
|        |      | - 0: Передача не завершена.                                                                   |
|        |      | - 1: Передача завершена.                                                                      |
| 6      | HPM  | High-priority message: Сообщение с высоким приоритетом                                        |
|        |      | - 0: Сообщение с высоким приоритетом не принято.                                              |
|        |      | - 1: Сообщение с высоким приоритетом принято.                                                 |
| 5      | RF1L | Rx FIFO 1 message lost: Сообщение в FIFO 1 приема потеряно                                    |
|        |      | - 0: Сообщение в FIFO 1 приема не потеряно.                                                   |
|        |      | - 1: Сообщение в FIFO 1 приема потеряно.                                                      |
| 4      | RF1F | Rx FIFO 1 full: FIFO 1 приема полон                                                           |
|        |      | - 0: FIFO 1 приема не полон.                                                                  |
|        |      | - 1: FIFO 1 приема полон.                                                                     |
| 3      | RF1N | Rx FIFO 1 new message: Новое сообщение в FIFO 1 приема                                        |
|        |      | - 0: Новое сообщение в FIFO 1 приема не записано.                                             |
|        |      | - 1: Новое сообщение записано в FIFO 1 приема.                                                |
| 2      | RF0L | Rx FIFO 0 message lost: Сообщение в FIFO 0 приема потеряно                                    |
|        |      | - 0: Сообщение в FIFO 0 приема не потеряно.                                                   |
|        |      | - 1: Сообщение в FIFO 0 приема потеряно.                                                      |
| 1      | RF0F | Rx FIFO 0 full: FIFO 0 приема полон                                                           |
|        |      | - 0: FIFO 0 приема не полон.                                                                  |
|        |      | - 1: FIFO 0 приема полон.                                                                     |
| 0      | RF0N | Rx FIFO 0 new message: Новое сообщение в FIFO 0 приема                                        |
|        |      | - 0: Новое сообщение в FIFO 0 приема не записано.                                             |
|        |      | - 1: Новое сообщение записано в FIFO 0 приема.                                                |

### Пример использования регистра FDCAN_IR

Рассмотрим пример кода для обработки различных прерываний из регистра FDCAN_IR и очистки соответствующих флагов.

Пример кода для обработки и очистки флагов прерываний:

```c
#define FDCAN_IR      (*(volatile uint32_t*)(0x40006450))

void handle_FDCAN_interrupts(void) {
    uint32_t ir_value = FDCAN_IR;

    // Обработка и очистка флагов прерываний
    if (ir_value & (1 << 23)) {
        // ARA: Access to reserved address
        printf("Access to reserved address occurred.\n");
        FDCAN_IR |= (1 << 23); // Очистка флага
    }
    if (ir_value & (1 << 22)) {
        // PED: Protocol error in data phase
        printf("Protocol error in data phase detected.\n");
        FDCAN_IR |= (1 << 22); // Очистка флага
    }
    if (ir_value & (1 << 21)) {
        // PEA: Protocol error in arbitration phase
        printf("Protocol error in arbitration phase detected.\n");
        FDCAN_IR |= (1 << 21); // Очистка флага
    }
    if (ir_value & (1 << 20)) {
        // WDI: Watchdog interrupt
        printf("Message RAM watchdog event occurred.\n");
        FDCAN_IR |= (1 << 20); // Очистка флага
    }
    if (ir_value & (1 << 19)) {
        // BO: Bus-off status
        printf("Bus-off status changed.\n");
        FDCAN_IR |= (1 << 19); // Очистка флага
    }
    if (ir_value & (1 << 18)) {
        // EW: Warning status
        printf("Error-warning status changed.\n");
        FDCAN_IR |= (1 << 18); // Очистка флага
    }
    if (ir_value & (1 << 17)) {
        // EP: Error passive
        printf("Error-passive status changed.\n");
        FDCAN_IR |= (1 << 17); // Очистка флага
    }
    if (ir_value & (1 << 16)) {
        // ELO: Error logging overflow
        printf("Error logging overflow occurred.\n");
        FDCAN_IR |= (1 << 16); // Очистка флага
    }
    if (ir_value & (1 << 15)) {
        // TOO: Timeout occurred
        printf("Timeout reached.\n");
        FDCAN_IR |= (1 << 15); // Очистка флага
    }
    if (ir_value & (1 << 14)) {
        // MRAF: Message RAM access failure
        printf("Message RAM access failure occurred.\n");
        FDCAN_IR |= (1 << 14); // Очистка флага
    }
    if (ir_value & (1 << 13)) {
        // TSW: Timestamp wraparound
        printf("Timestamp counter wrapped around.\n");
        FDCAN_IR |= (1 << 13); // Очистка флага
    }
    if (ir_value & (1 << 12)) {
        // TEFL: Tx event FIFO element lost
        printf("Tx event FIFO element lost.\n");
        FDCAN_IR |= (1 << 12); // Очистка флага
    }
    if (ir_value & (1 << 11)) {
        // TEFF: Tx event FIFO full
        printf("Tx event FIFO full.\n");
        FDCAN_IR |= (1 << 11); // Очистка флага
    }
    if (ir_value & (1 << 10)) {
        // TEFN: Tx event FIFO new entry
        printf("Tx handler wrote Tx event FIFO element.\n");
        FDCAN_IR |= (1 << 10); // Очистка флага
    }
    if (ir_value & (1 << 9)) {
        // TFE: Tx FIFO empty
        printf("Tx FIFO empty.\n");
        FDCAN_IR |= (1 << 9); // Очистка флага
    }
    if (ir_value & (1 << 8)) {
        // TCF: Transmission cancellation finished
        printf("Transmission cancellation finished.\n");
        FDCAN_IR |= (1 << 8); // Очистка флага
    }
    if (ir_value & (1 << 7)) {
        // TC: Transmission completed
        printf("Transmission completed.\n");
        FDCAN_IR |= (1 << 7); // Очистка флага
    }
    if (ir_value & (1 << 6)) {
        // HPM: High-priority message received
        printf("High-priority message received.\n");
        FDCAN_IR |= (1 << 6); // Очистка флага
    }
    if (ir_value & (1 << 5)) {
        // RF1L: Rx FIFO 1 message lost
        printf("Rx FIFO 1 message lost.\n");
        FDCAN_IR |= (1 << 5); // Очистка флага
    }
    if (ir_value & (1 << 4)) {
        // RF1F: Rx FIFO 1 full
        printf("Rx FIFO 1 full.\n");
        FDCAN_IR |= (1 << 4); // Очистка флага
    }
    if (ir_value & (1 << 3)) {
        // RF1N: Rx FIFO 1 new message
        printf("New message written to Rx FIFO 1.\n");
        FDCAN_IR |= (1 << 3); // Очистка флага
    }
    if (ir_value & (1 << 2)) {
        // RF0L: Rx FIFO 0 message lost
        printf("Rx FIFO 0 message lost.\n");
        FDCAN_IR |= (1 << 2); // Очистка флага
    }
    if (ir_value & (1 << 1)) {
        // RF0F: Rx FIFO 0 full
        printf("Rx FIFO 0 full.\n");
        FDCAN_IR |= (1 << 1); // Очистка флага
    }
    if (ir_value & (1 << 0)) {
        // RF0N: Rx FIFO 0 new message
        printf("New message written to Rx FIFO 0.\n");
        FDCAN_IR |= (1 << 0); // Очистка флага
    }
}

int main(void) {
    // Настройка системного тактирования (предполагается, что уже настроено)

    // Основной цикл программы
    while (1) {
        // Обработка прерываний FDCAN
        handle_FDCAN_interrupts();

        // Задержка для демонстрации периодической обработки (например, 1 секунда)
        HAL_Delay(1000);
    }
}

void Error_Handler(void) {
    // Обработка ошибок
    __disable_irq();
    while (1) {
    }
}
```

### Объяснение кода:

1. **handle_FDCAN_interrupts()**:
   - Считывает значение регистра FDCAN_IR.
   - Проверяет и обрабатывает каждый флаг прерывания, выводя соответствующее сообщение на консоль.
   - Очищает флаг прерывания, записывая 1 в соответствующий бит регистра FDCAN_IR.

2. **main()**:
   - Настраивает системное тактирование (предполагается, что уже настроено).
   - В основном цикле программы периодически вызывает функцию handle_FDCAN_interrupts() для обработки прерываний и вывода информации на консоль.

Этот пример демонстрирует, как использовать регистр FDCAN_IR для обработки различных прерываний в модуле FDCAN, а также как очищать флаги прерываний после их обработки.

### Регистр состояния Rx FIFO 0 (FDCAN_RXF0S)

Регистр состояния Rx FIFO 0 (FDCAN_RXF0S) предоставляет информацию о состоянии FIFO 0 приемника в модуле FDCAN. Этот регистр имеет смещение адреса 0x0090 и значение по умолчанию 0x0000 0000 после сброса.

#### Описание полей регистра FDCAN_RXF0S

| Бит    | Поле   | Описание                                                                                       |
|--------|--------|------------------------------------------------------------------------------------------------|
| 31:26  |        | Зарезервировано, должно быть установлено в значение по умолчанию.                              |
| 25     | RF0L   | Rx FIFO 0 message lost: Потеряно сообщение в Rx FIFO 0                                          |
|        |        | - 0: Сообщение в Rx FIFO 0 не потеряно.                                                        |
|        |        | - 1: Сообщение в Rx FIFO 0 потеряно, также установлено после попытки записи в FIFO 0 размером 0. |
| 24     | F0F    | Rx FIFO 0 full: Rx FIFO 0 полон                                                                |
|        |        | - 0: Rx FIFO 0 не полон.                                                                       |
|        |        | - 1: Rx FIFO 0 полон.                                                                          |
| 23:18  |        | Зарезервировано, должно быть установлено в значение по умолчанию.                              |
| 17:16  | F0PI   | Rx FIFO 0 put index: Индекс записи в Rx FIFO 0                                                 |
|        |        | - Указатель индекса записи в Rx FIFO 0.                                                        |
|        |        | - Диапазон: 0 - 2.                                                                             |
| 15:10  |        | Зарезервировано, должно быть установлено в значение по умолчанию.                              |
| 9:8    | F0GI   | Rx FIFO 0 get index: Индекс чтения из Rx FIFO 0                                                |
|        |        | - Указатель индекса чтения из Rx FIFO 0.                                                       |
|        |        | - Диапазон: 0 - 2.                                                                             |
| 7:4    |        | Зарезервировано, должно быть установлено в значение по умолчанию.                              |
| 3:0    | F0FL   | Rx FIFO 0 fill level: Уровень заполнения Rx FIFO 0                                             |
|        |        | - Количество элементов, хранящихся в Rx FIFO 0.                                                |
|        |        | - Диапазон: 0 - 3.                                                                             |

### Регистр подтверждения Rx FIFO 0 (FDCAN_RXF0A)

Регистр подтверждения Rx FIFO 0 (FDCAN_RXF0A) используется для подтверждения чтения сообщений из FIFO 0 приемника. Этот регистр имеет смещение адреса 0x0094 и значение по умолчанию 0x0000 0000 после сброса.

#### Описание полей регистра FDCAN_RXF0A

| Бит    | Поле   | Описание                                                                                       |
|--------|--------|------------------------------------------------------------------------------------------------|
| 31:3   |        | Зарезервировано, должно быть установлено в значение по умолчанию.                              |
| 2:0    | F0AI   | Rx FIFO 0 acknowledge index: Индекс подтверждения Rx FIFO 0                                     |
|        |        | - После того как хост прочитал сообщение или последовательность сообщений из Rx FIFO 0, он должен записать индекс буфера последнего прочитанного элемента в F0AI[2:0]. |
|        |        | - Это устанавливает индекс чтения Rx FIFO 0 (F0GI[1:0] регистра FDCAN_RXF0S) в значение F0AI[2:0] + 1 и обновляет уровень заполнения FIFO 0 (F0FL[3:0] регистра FDCAN_RXF0S). |

### Пример использования регистров FDCAN_RXF0S и FDCAN_RXF0A

Рассмотрим пример кода для чтения состояния Rx FIFO 0 и подтверждения чтения сообщений.

Пример кода для чтения состояния Rx FIFO 0 и подтверждения чтения сообщений:

```c
#define FDCAN_RXF0S      (*(volatile uint32_t*)(0x40006490))
#define FDCAN_RXF0A      (*(volatile uint32_t*)(0x40006494))

void read_and_acknowledge_rx_fifo0(void) {
    uint32_t rxf0s_value = FDCAN_RXF0S;

    // Извлечение значений полей из регистра FDCAN_RXF0S
    uint8_t RF0L = (rxf0s_value >> 25) & 0x01; // Потеряно сообщение в Rx FIFO 0
    uint8_t F0F = (rxf0s_value >> 24) & 0x01;  // Rx FIFO 0 полон
    uint8_t F0PI = (rxf0s_value >> 16) & 0x03; // Индекс записи в Rx FIFO 0
    uint8_t F0GI = (rxf0s_value >> 8) & 0x03;  // Индекс чтения из Rx FIFO 0
    uint8_t F0FL = rxf0s_value & 0x0F;         // Уровень заполнения Rx FIFO 0

    // Вывод значений на консоль
    printf("RF0L: %u\n", RF0L);
    printf("F0F: %u\n", F0F);
    printf("F0PI: %u\n", F0PI);
    printf("F0GI: %u\n", F0GI);
    printf("F0FL: %u\n", F0FL);

    // Подтверждение чтения сообщений из Rx FIFO 0
    // Предположим, что мы читаем все доступные сообщения
    if (F0FL > 0) {
        uint8_t last_read_index = (F0GI + F0FL - 1) % 3; // Индекс последнего прочитанного элемента
        FDCAN_RXF0A = last_read_index; // Запись индекса в регистр подтверждения
        printf("Acknowledged reading messages up to index: %u\n", last_read_index);
    }
}

int main(void) {
    // Настройка системного тактирования (предполагается, что уже настроено)

    // Основной цикл программы
    while (1) {
        // Чтение состояния Rx FIFO 0 и подтверждение чтения сообщений
        read_and_acknowledge_rx_fifo0();

        // Задержка для демонстрации периодической обработки (например, 1 секунда)
        HAL_Delay(1000);
    }
}

void Error_Handler(void) {
    // Обработка ошибок
    __disable_irq();
    while (1) {
    }
}
```

### Объяснение кода:

1. **read_and_acknowledge_rx_fifo0()**:
   - Считывает значение регистра FDCAN_RXF0S.
   - Извлекает значения полей RF0L, F0F, F0PI, F0GI и F0FL из регистра.
   - Выводит значения на консоль.
   - Подтверждает чтение сообщений из Rx FIFO 0, записывая индекс последнего прочитанного элемента в регистр FDCAN_RXF0A.

2. **main()**:
   - Настраивает системное тактирование (предполагается, что уже настроено).
   - В основном цикле программы периодически вызывает функцию read_and_acknowledge_rx_fifo0() для чтения состояния Rx FIFO 0 и подтверждения чтения сообщений.

Этот пример демонстрирует, как использовать регистры FDCAN_RXF0S и FDCAN_RXF0A для мониторинга состояния Rx FIFO 0 и подтверждения чтения сообщений в модуле FDCAN.

#include "stm32g4xx.h"

// Определение скорости обмена
typedef enum {
    CAN_SPEED_1000K = 1000,
    CAN_SPEED_800K = 800,
    CAN_SPEED_500K = 500,
    CAN_SPEED_250K = 250,
    CAN_SPEED_125K = 125
} CAN_Speed;

// Функция для настройки CAN
void CAN_Config(uint32_t core_frequency, CAN_Speed speed) {
    // Включение тактирования FDCAN
    RCC->APB1ENR1 |= RCC_APB1ENR1_FDCANEN;

    // Перевод в режим инициализации
    FDCAN1->CCCR |= FDCAN_CCCR_INIT;
    while (!(FDCAN1->CCCR & FDCAN_CCCR_INIT)); // Ожидание входа в режим инициализации

    // Настройка режима
    FDCAN1->CCCR &= ~FDCAN_CCCR_TEST; // Обычный режим
    FDCAN1->CCCR |= FDCAN_CCCR_CCE; // Разрешение изменения конфигурации

    // Определение параметров для настройки
    uint32_t prescaler = 0;
    uint32_t TSEG1 = 0;
    uint32_t TSEG2 = 0;
    uint32_t SJW = 1; // Ширина джиттера (обычно 1 или 2)

    // Настройка скорости передачи
    switch (speed) {
        case CAN_SPEED_1000K:
            prescaler = core_frequency / 1000000; // 75MHz / 1Mbit/s
            TSEG1 = 12; // Примерное значение
            TSEG2 = 3;  // Примерное значение
            break;
        case CAN_SPEED_800K:
            prescaler = core_frequency / 800000; // 75MHz / 800kbit/s
            TSEG1 = 12; // Примерное значение
            TSEG2 = 3;  // Примерное значение
            break;
        case CAN_SPEED_500K:
            prescaler = core_frequency / 500000; // 75MHz / 500kbit/s
            TSEG1 = 25; // Примерное значение
            TSEG2 = 4;  // Примерное значение
            break;
        case CAN_SPEED_250K:
            prescaler = core_frequency / 250000; // 75MHz / 250kbit/s
            TSEG1 = 50; // Примерное значение
            TSEG2 = 6;  // Примерное значение
            break;
        case CAN_SPEED_125K:
            prescaler = core_frequency / 125000; // 75MHz / 125kbit/s
            TSEG1 = 100; // Примерное значение
            TSEG2 = 8;   // Примерное значение
            break;
        default:
            prescaler = core_frequency / 500000; // По умолчанию 500kbit/s
            TSEG1 = 25;
            TSEG2 = 4;
            break;
    }

    // Настройка битовой скорости
    FDCAN1->NBTP = (prescaler - 1) | (TSEG1 << 16) | (TSEG2 << 20) | (SJW << 24);

    // Перевод в нормальный режим
    FDCAN1->CCCR &= ~FDCAN_CCCR_INIT; // Вход в нормальный режим
    while (FDCAN1->CCCR & FDCAN_CCCR_INIT); // Ожидание выхода из режима инициализации
}

Хорошо давай напишем код CMSIS настройки скорости 1000,800,500,250,125
Частота  микроконтроллера STM32G431 160 мгц, 
Частота ядра CANFD div /2  80мгц
Исходя из формул 
Например скорость 500кбит
Tq = 80000000 / 500000
NSEG1 Tqx0,85
NSEG2 Tqx0,15 
Prescaler 1
-------------------------------------------------------------------------------

void FDCAN1_init(void)
{
    unsigned long *ptr, *i;
    unsigned long computed_can_freq;
    double temp;

    usart1_send_string("\nFDCAN: Init...");

    temp = (double)1 / pll2_q_value;    
    temp = temp * CAN_PRESCALER;
    temp = temp * (CAN_SYNC_SEG + CAN_PHASE_SEG1 + CAN_PHASE_SEG2);
    computed_can_freq = (double)1 / temp;

    usart1_send_string("\nFDCAN: Computed frequency: ");
    usart1_ulong32_10digits(computed_can_freq);
    usart1_send_string(" MHz\n");

    // Настройка GPIO для CAN RX и TX
    gpio_init(PORT_A, 11, MODE_ALT_F, TYPE_PUSH_PULL, SPEED_MAX, PULL_NO, ALTF_9); // RX
    gpio_init(PORT_A, 12, MODE_ALT_F, TYPE_PUSH_PULL, SPEED_MAX, PULL_NO, ALTF_9); // TX

    // Выбор источника тактирования для FDCAN
    RCC->CCIPR |= RCC_CCIPR_FDCANSEL_1; // pll2_q_ck clock is selected as FDCAN

    // Включение тактирования для FDCAN
    RCC->APB1ENR1 |= RCC_APB1ENR1_FDCANEN; 

    // Инициализация модуля FDCAN
    FDCAN1->CCCR |= FDCAN_CCCR_INIT;               
    while ((FDCAN1->CCCR & FDCAN_CCCR_INIT) == 0) {};
    
    // Включение возможности изменения конфигурации
    FDCAN1->CCCR |= FDCAN_CCCR_CCE;

    // Настройка классического CAN
    FDCAN1->CCCR &= ~(FDCAN_CCCR_FDOE);          

    // Включение авто-повтора
    FDCAN1->CCCR |= FDCAN_CCCR_DAR; // RETR OFF
    
    // Test mode, Internal loopback
    #ifdef CAN_TESTMODE
        FDCAN1->CCCR |= FDCAN_CCCR_TEST;
        FDCAN1->TEST |= FDCAN_TEST_LBCK;
    #endif

    // Очистка памяти сообщений
    for (i = (unsigned long*)FDCAN_MEM_START_ADDR; i < (unsigned long*)FDCAN_MEM_END_ADDR; i++) *i = 0;

    // Настройка таймингов
    FDCAN1->NBTP = (CAN_SYNC_JW - 1) << FDCAN_NBTP_NSJW_Pos;
    FDCAN1->NBTP |= (CAN_PRESCALER - 1) << FDCAN_NBTP_NBRP_Pos;
    FDCAN1->NBTP |= (CAN_PHASE_SEG1 - 1) << FDCAN_NBTP_NTSEG1_Pos;
    FDCAN1->NBTP |= (CAN_PHASE_SEG2 - 1) << FDCAN_NBTP_NTSEG2_Pos;

    FDCAN1->DBTP = (CAN_SYNC_JW - 1) << FDCAN_DBTP_DSJW_Pos;
    FDCAN1->DBTP |= (CAN_PRESCALER - 1) << FDCAN_DBTP_DBRP_Pos;
    FDCAN1->DBTP |= (CAN_PHASE_SEG1 - 1) << FDCAN_DBTP_DTSEG1_Pos;
    FDCAN1->DBTP |= (CAN_PHASE_SEG2 - 1) << FDCAN_DBTP_DTSEG2_Pos;

    // Настройка фильтров (если включены)
    #ifdef CAN_ENABLE_FILTERS
        FDCAN1->GFC |= FDCAN_GFC_ANFS; // Reject non-matching frames standard
        FDCAN1->GFC |= FDCAN_GFC_ANFE; // Reject non-matching frames extended
        FDCAN1->GFC |= FDCAN_GFC_RRFS; // Reject all remote frames with 11-bit standard ID
        FDCAN1->GFC |= FDCAN_GFC_RRFE; // Reject all remote frames with 29-bit standard ID

        FDCAN1->SIDFC = (FDCAN_11B_FILTER_EL_CNT << FDCAN_SIDFC_LSS_Pos); // standard filter count
        FDCAN1->XIDFC = (FDCAN_29B_FILTER_EL_CNT << FDCAN_XIDFC_LSE_Pos); // extended filter count

        FDCAN1->SIDFC |= (FDCAN_11B_FILTER_OFFSET << FDCAN_SIDFC_FLSSA_Pos); // standard filter start address
        FDCAN1->XIDFC |= (FDCAN_29B_FILTER_OFFSET << FDCAN_XIDFC_FLESA_Pos); // extended filter start address

        // Настройка стандартных фильтров
        ptr = (unsigned long*)FCCAN_11B_FILTER_START_ADDR; // get start address for pointer
        // *ptr++ = (FILTER_TYPE_DUAL << 30) | (FILTER_CFG_STORE_FIFO_0 << 27) | (CAN_TEST_ID_0 << 16) | (CAN_TEST_ID_1);
        // *ptr++ = (FILTER_TYPE_DUAL << 30) | (FILTER_CFG_STORE_FIFO_0 << 27) | (CAN_TEST_ID_2 << 16) | (CAN_TEST_ID_3);

        // Настройка расширенных фильтров
        ptr = (unsigned long*)FCCAN_29B_FILTER_START_ADDR; // get start address for pointer
        *ptr++ = (FILTER_CFG_STORE_FIFO_0 << 29) | (CAN_TEST_ID_0);
        *ptr++ = (FILTER_TYPE_DUAL << 30) | (CAN_TEST_ID_1);
    #else
        FDCAN1->SIDFC = 0;
        FDCAN1->GFC = 0;
    #endif

    // Настройка RX FIFO 0
    FDCAN1->RXF0C = FDCAN_RX_FIFO_0_OFFSET << FDCAN_RXF0C_F0SA_Pos;
    FDCAN1->RXF0C |= FDCAN_RX_FIFO_0_EL_CNT << FDCAN_RXF0C_F0S_Pos;

    // TX event
    FDCAN1->TXEFC = 0; // No Event

    // Настройка TX FIFO
    FDCAN1->TXBC &= ~(FDCAN_TXBC_TFQM); // FIFO operation
    FDCAN1->TXBC |= FDCAN_TX_FIFO_EL_CNT << FDCAN_TXBC_TFQS_Pos;
    FDCAN1->TXBC |= FDCAN_TX_FIFO_OFFSET << FDCAN_TXBC_TBSA_Pos;
                
    // Включение прерываний для RX FIFO 0
    FDCAN1->IE |= FDCAN_IE_RF0NE;

    // Включение линии прерываний 0
    FDCAN1->ILE |= FDCAN_ILE_EINT0;

    // Выход из режима инициализации
    FDCAN1->CCCR &= ~(FDCAN_CCCR_INIT);
    while ((FDCAN1->CCCR & FDCAN_CCCR_INIT) == 1) {};

    // Включение прерываний статуса и ошибок
    NVIC_EnableIRQ(FDCAN1_IT0_IRQn);

    usart1_send_string("FDCAN: Init complete!\n");
}
void FDCAN1_send_msg(struct can_message *msg)
{
    struct can_fifo_element *fifo;
    unsigned char tx_index;

    // Проверка наличия свободного буфера передачи
    if ((FDCAN1->TXFQS & FDCAN_TXFQS_TFQF) != 0)
    {
        // Очередь передачи заполнена
        return;
    }

    // Получение индекса вставки
    tx_index = (FDCAN1->TXFQS >> 16) & 0xF;

    // Адрес буфера передачи
    fifo = (struct can_fifo_element *)(FDCAN_TX_FIFO_START_ADDR + tx_index * FDCAN_TX_FIFO_EL_SIZE);

    if (msg->format == CAN_STANDARD_FORMAT)
    {
        fifo->word0 = (msg->id << 18);
    }
    else
    {
        fifo->word0 = msg->id;
        fifo->word0 |= 1UL << 30; // extended flag
    }

    if (msg->type == REMOTE_FRAME) fifo->word0 |= 1UL << 29;

    fifo->word1 = (8UL << 16);  // Data size
    fifo->word2 = (msg->data[3] << 24)|(msg->data[2] << 16)|(msg->data[1] << 8)|msg->data[0];
    fifo->word3 = (msg->data[7] << 24)|(msg->data[6] << 16)|(msg->data[5] << 8)|msg->data[4];

    // Запрос на передачу сообщения
    FDCAN1->TXBAR |= (1UL << tx_index);   
}
void FDCAN1_read_msg(struct can_message* msg, unsigned char idx)
{
    struct can_fifo_element *fifo;

    fifo = (struct can_fifo_element*)(FDCAN_RX_FIFO_0_START_ADDR + idx * FDCAN_RX_FIFO_0_EL_SIZE);

    msg->error = (unsigned char)((fifo->word0 >> 31) & 0x01);
    msg->format = (unsigned char)((fifo->word0 >> 30) & 0x01);
    msg->type = (unsigned char)((fifo->word0 >> 29) & 0x01);

    if (msg->format == CAN_EXTENDED_FORMAT)
    {
        msg->id = fifo->word0 & 0x1FFFFFFF;
    }
    else
    {
        msg->id = (fifo->word0 >> 18) & 0x7FF;
    }

    msg->length = (unsigned char)((fifo->word1 >> 16) & 0x0F);

    msg->data[0] = (unsigned char)((fifo->word2 >>  0) & 0xFF);
    msg->data[1] = (unsigned char)((fifo->word2 >>  8) & 0xFF);
    msg->data[2] = (unsigned char)((fifo->word2 >> 16) & 0xFF);
    msg->data[3] = (unsigned char)((fifo->word2 >> 24) & 0xFF);

    msg->data[4] = (unsigned char)((fifo->word3 >>  0) & 0xFF);
    msg->data[5] = (unsigned char)((fifo->word3 >>  8) & 0xFF);
    msg->data[6] = (unsigned char)((fifo->word3 >> 16) & 0xFF);
    msg->data[7] = (unsigned char)((fifo->word3 >> 24) & 0xFF);
}
void FDCAN1_IT0_IRQHandler(void)
{
    unsigned char index_fifo;

    // Новое сообщение получено
    if((FDCAN1->IR & FDCAN_IR_RF0N) != 0)
    {
        FDCAN1->IR = FDCAN_IR_RF0N; // сброс флага
        rx_fifo_get_index = (unsigned char)((FDCAN1->RXF0S >> 8) & 0x3F);
        FDCAN1_read_msg(&can_rx_message, rx_fifo_get_index);
        new_message_received = 1;
        FDCAN1->RXF0A = rx_fifo_get_index;
    }

    // Сообщение потеряно
    if((FDCAN1->IR & FDCAN_IR_RF0L) != 0)
    {
        FDCAN1->IR = FDCAN_IR_RF0L; // сброс флага
    }

    // RX FIFO 0 полон
    if((FDCAN1->IR & FDCAN_IR_RF0F) != 0)
    {
        while(FDCAN1->RXF0S & FDCAN_RXF0S_F0FL_Msk)
        {
            rx_fifo_get_index = (uint8_t)((FDCAN1->RXF0S >> 8) & 0x1F);
            FDCAN1_read_msg(&can_rx_message, rx_fifo_get_index);
            FDCAN1->RXF0A = rx_fifo_get_index;
        }
        FDCAN1->IR = FDCAN_IR_RF0F;
    }
}
int main(void)
{
    // Настройка системного тактирования (предполагается, что уже настроено)
    // SystemClock_Config();

    // Настройка FDCAN
    FDCAN1_init();

    // Настройка USART для вывода сообщений
    usart1_init();

    // Настройка GPIO для управления светодиодом
    gpio_init(GPIOI, 16, MODE_OUTPUT, TYPE_PUSH_PULL, SPEED_LOW, PULL_NO);

    // Пример сообщения для отправки
    can_tx_message.id = 0x123;
    can_tx_message.format = CAN_STANDARD_FORMAT;
    can_tx_message.type = DATA_FRAME;
    can_tx_message.length = 8;
    can_tx_message.data[0] = 0x11;
    can_tx_message.data[1] = 0x22;
    can_tx_message.data[2] = 0x33;
    can_tx_message.data[3] = 0x44;
    can_tx_message.data[4] = 0x55;
    can_tx_message.data[5] = 0x66;
    can_tx_message.data[6] = 0x77;
    can_tx_message.data[7] = 0x88;

    while (1)
    {
        // Отправка сообщения
        FDCAN1_send_msg(&can_tx_message);

        // Ожидание получения сообщения
        if (new_message_received)
        {
            new_message_received = 0;
            usart1_send_string("Received CAN message: ");
            usart1_send_data(can_rx_message.data, can_rx_message.length);
            usart1_send_string("\n");
        }

        // Пример управления светодиодом
        LED_ON;
        HAL_Delay(100);
        LED_OFF;
        HAL_Delay(100);
    }

    return 0;
}


